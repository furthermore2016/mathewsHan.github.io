<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小程序开发</title>
    <url>/2020/03/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="non-writable-modification-of-global-variable-“App”-is-not-allowed-when-using-plugins-at-app-json"><a href="#non-writable-modification-of-global-variable-“App”-is-not-allowed-when-using-plugins-at-app-json" class="headerlink" title="[non-writable] modification of global variable “App” is not allowed when using plugins at app.json."></a>[non-writable] modification of global variable “App” is not allowed when using plugins at app.json.</h1><p>2018-10-09<br>使用插件时，为了保护小程序和插件，全局变量不能修改，请检查代码中是否有对 Page 和 App 两个全局量做了改动</p>
<p>// 小程序的目录结构<br>1.app.js是小程序的脚本代码。</p>
<pre><code>  我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。
</code></pre><p>2.app.json 是对整个小程序的全局配置。</p>
<pre><code>   我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。
</code></pre><p>3.app.wxss 是整个小程序的公共样式表。</p>
<pre><code>   我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。全局样式，
</code></pre><p>4.创建页面pages</p>
<pre><code>  如:index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页。

 微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。
</code></pre>]]></content>
  </entry>
  <entry>
    <title>macOS使用问题</title>
    <url>/2019/12/14/macOS%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>//——————————-macOS———————————————</p>
<h1 id="解决Homebrew下载更新极慢的问题-更换国内镜像源"><a href="#解决Homebrew下载更新极慢的问题-更换国内镜像源" class="headerlink" title="解决Homebrew下载更新极慢的问题,更换国内镜像源"></a>解决Homebrew下载更新极慢的问题,更换国内镜像源</h1><p> Posted on 2019-05-04<br>使用brew update —verbose观察update过程：</p>
<p>发现update卡在从github仓库获取文件的过程。这个结果与手动从github下载文件慢的症状相互印证。<br>更换使用国内的homebrew镜像源；使用代理访问github.com。更换Homebrew源,使用以下命令更换国内阿里云上的homebrew镜像：<br>1.替换brew.git:<br>cd “$(brew —repo)”<br>git remote set-url origin <a href="https://mirrors.aliyun.com/homebrew/brew.git" target="_blank" rel="noopener">https://mirrors.aliyun.com/homebrew/brew.git</a><br>2.替换homebrew-core.git:<br>cd “$(brew —repo)/Library/Taps/homebrew/homebrew-core”<br>git remote set-url origin <a href="https://mirrors.aliyun.com/homebrew/homebrew-core.git" target="_blank" rel="noopener">https://mirrors.aliyun.com/homebrew/homebrew-core.git</a><br>3.替换homebrew-bottles:<br>echo ‘export HOMEBREW_BOTTLE_DOMAIN=<a href="https://mirrors.aliyun.com/homebrew/homebrew-bottles" target="_blank" rel="noopener">https://mirrors.aliyun.com/homebrew/homebrew-bottles</a>‘ &gt;&gt; ~/.zshrc<br>source ~/.zshrc<br>替换后，问题依旧，继续查看日志：<br>可以看到由于homebrew-cask的仓库依然指向了Github，这个过程还是慢。阿里云的镜像站没有提供homebrew-cask，进一步搜索找到USTC镜像站，该站提供了homebrew-cask的源。使用上述同样的命令更换源：<br>4.替换homebrew-cask.git:<br>cd “$(brew —repo)”/Library/Taps/homebrew/homebrew-cask<br>git remote set-url origin <a href="https://mirrors.ustc.edu.cn/homebrew-cask.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/homebrew-cask.git</a><br>测试发现问题解决。<br>官方源地址：<br><a href="https://github.com/Homebrew/brew.git" target="_blank" rel="noopener">https://github.com/Homebrew/brew.git</a><br><a href="https://github.com/Homebrew/homebrew-core.git" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-core.git</a><br><a href="https://github.com/Homebrew/homebrew-cask" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-cask</a></p>
<h1 id="homebrew-常用命令"><a href="#homebrew-常用命令" class="headerlink" title="homebrew  常用命令"></a>homebrew  常用命令</h1><p>1、通过brew install安装应用最先是放在/usr/local/Cellar/目录下。<br>有些应用会自动创建软链接放在/usr/bin或者/usr/sbin，同时也会将整个文件夹放在/usr/local<br>可以使用 brew list 软件名 (比如 brew list oclint)确定安装位置</p>
<p>例如 :  brew list oclint<br>sudo find / -name “autojump”<br>//查找autojump 安装位置<br>brew config | grep HOMEBREW<br>//查找 config配置文件<br>brew list           列出已安装的软件<br>brew update     更新brew<br>brew home       用浏览器打开brew的官方网站<br>brew info         显示软件信息<br>brew deps        显示包依赖</p>
<h1 id="homebrew-安装-nginx"><a href="#homebrew-安装-nginx" class="headerlink" title="homebrew  安装  nginx  ,"></a>homebrew  安装  nginx  ,</h1><p>brew install nginx</p>
<p>open /usr/local/Cellar/nginx<br>//servic nginx start<br>/usr/sbin/nginx          yum安装的nginx也可以使用<br>/usr/local/nginx/sbin/nginx -t<br>/usr/local/nginx/sbin/nginx -s reload<br>/usr/local/nginx/sbin/nginx -s stop</p>
<h1 id="macOS-使用的命令行"><a href="#macOS-使用的命令行" class="headerlink" title="macOS 使用的命令行"></a>macOS 使用的命令行</h1><p>lsof -i :8080</p>
<h1 id="zsh-与-macOS原生bash"><a href="#zsh-与-macOS原生bash" class="headerlink" title="zsh 与  macOS原生bash"></a>zsh 与  macOS原生bash</h1><p>两者切换问题 ：zsh切换bash bash切换zsh<br>切换bash<br>chsh -s /bin/bash</p>
<p>切换zsh<br>chsh -s /bin/zsh</p>
<p>chmod  777   -R<br>chmod  -rwx rwx  rwx   -R<br>     拥有者   群组   其他人 </p>
<p>直接查阅文档可使用  cat/tac(反向显示)/nl 等命令,   cat是  concatenate的缩写</p>
<h1 id="macOS的环境变量配置"><a href="#macOS的环境变量配置" class="headerlink" title="macOS的环境变量配置"></a>macOS的环境变量配置</h1><p>Mac系统的环境变量，加载顺序为：<br>/etc/profile<br>/etc/paths<br>~/.bash_profile<br>~/.bash_login<br>~/.profile<br>~/.bashrc</p>
<h1 id="macOS快捷键"><a href="#macOS快捷键" class="headerlink" title="macOS快捷键"></a>macOS快捷键</h1><p>空格 预览 word 等<br>Commacnd + n 新建窗口<br>command + shift  + 3  截取全屏<br>command + shift  + 3  截取区域<br>commoand  +  tab +  -&gt;<br>command + 2（数字 ） 跳到浏览器指定页面</p>
<p>显示简介—打方方式——-全部更改———-</p>
<p>//———————linux内核()—————-<br>fork() 函数</p>
<p>poll()<br>epoll()<br>//—————————————开发工具————————————</p>
<h1 id="gradle-构建"><a href="#gradle-构建" class="headerlink" title="gradle 构建"></a>gradle 构建</h1><p>1.依赖管理<br>相较于传统  maven构建 , maven 使用 xml 管理项目的基本信息，构建过程，环境信息，依赖信息等。<br>而  gradle  , 用 :链接 数值 ， compile 函数引入依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) &#123;</span><br><span class="line">        exclude module: &quot;spring-boot-starter-tomcat&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    compile(&quot;org.springframework.boot:spring-boot-starter-security&quot;)</span><br><span class="line">    compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;)</span><br><span class="line">    testCompile(&quot;mysql:mysql-connector-java:5.1.25&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>构建生命周期  maven   &amp; grandle<br>在Maven中每个任务的goal称作Mojo</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Interestting Leetcode</title>
    <url>/2019/12/13/Interestting-Leetcode/</url>
    <content><![CDATA[<h1 id="Validate-IP-Address"><a href="#Validate-IP-Address" class="headerlink" title="Validate IP Address"></a>Validate IP Address</h1><p>In this  problem ,your job to write a function to check whether a input string is a valid IPv4 address or IPv6 address or neither.</p>
<p>Exampled 1:<br>Input :”172.16.254.1”<br>Output : “IPV4”<br>Explanation: this is  a valid  IP  address</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string validIPAddress(string IP) &#123;</span><br><span class="line">        istringstream is(IP);</span><br><span class="line">        string t = &quot;&quot;;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        if (IP.find(&apos;:&apos;) == string::npos) &#123; // Check IPv4</span><br><span class="line">            while (getline(is, t, &apos;.&apos;)) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                if (cnt &gt; 4 || t.empty() || (t.size() &gt; 1 &amp;&amp; t[0] == &apos;0&apos;) || t.size() &gt; 3) return &quot;Neither&quot;;</span><br><span class="line">                for (char c : t) &#123;</span><br><span class="line">                    if (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) return &quot;Neither&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                int val = stoi(t);</span><br><span class="line">                if (val &lt; 0 || val &gt; 255) return &quot;Neither&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            return (cnt == 4 &amp;&amp; IP.back() != &apos;.&apos;) ? &quot;IPv4&quot; : &quot;Neither&quot;;</span><br><span class="line">        &#125; else &#123; // Check IPv6</span><br><span class="line">            while (getline(is, t, &apos;:&apos;)) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                if (cnt &gt; 8 || t.empty() || t.size() &gt; 4) return &quot;Neither&quot;;</span><br><span class="line">                for (char c : t) &#123;</span><br><span class="line">                    if (!(c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &amp;&amp; !(c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;f&apos;) &amp;&amp; !(c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;F&apos;)) return &quot;Neither&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return (cnt == 8 &amp;&amp; IP.back() != &apos;:&apos;) ? &quot;IPv6&quot; : &quot;Neither&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2019/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>所谓的钩子函数和拦截器的关系,hook函数<br>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p>
<p>它的函数只能返回字串，无法返回数组<br>它不支持面向对象，你无法实现一些优雅的设计模式<br>它是解释型的，一边解释一边执行，连PHP那种预编译都不是</p>
<h1 id="开发原则"><a href="#开发原则" class="headerlink" title="开发原则"></a>开发原则</h1><p>1.开闭  (OCP   open-close Principle )</p>
<ol>
<li>依赖倒置  (Dependency   Inversion  Principle  ,DIP)实际上就是依赖注入<br>3.迪米特原则</li>
</ol>
<hr>
<p>华丽分割线</p>
<h1 id="例子：多流程判断-，干掉-if-else-的手段—策略模式"><a href="#例子：多流程判断-，干掉-if-else-的手段—策略模式" class="headerlink" title="例子：多流程判断 ，干掉 if-else 的手段—策略模式"></a>例子：多流程判断 ，干掉 if-else 的手段—策略模式</h1><p>典型场景 ： 支付渠道<br>需求分析 ： 共性 ，个性 ?</p>
<p>spring 1代  ： 配置文件</p>
<p>/**</p>
<ul>
<li>计算金额使用 BigDecimal </li>
<li><p>double 2 = 1.99999<br>/<br>public  interface  Strategy{</p>
<p> BidDecimal   calRecharge(Integer channelId ,Integer  goodsId);<br>}</p>
</li>
</ul>
<p>//工商银行支付 实现类<br>public class ICBCPay  implememts Strategy{</p>
<pre><code>@Resource
private  CodeChannelMapper  codeChannelMapper;

@Resource 
private   CodeeGoodsMapper   codeGoodsMapper;

public BigDecimal  calRecharge (Integer  channelId , Interger goodsId){

    CodeGoods  codeGoods =  codeGoodsMapper.selectByPrimaryKey(channelId);

    CodeChannel   codeChannel  = codeChannelMapper.selectByPrimaryKey(goodsId);
    if(codeGoods!=null &amp;&amp; codeChannel!=null){
    return codeGoods.getAmout().multiply（codeChannel.getDisAmount()）;
    }
}
</code></pre><p>}</p>
<p>//状态机  if—&gt;对应的东西<br>public class  Context{</p>
<pre><code>private  Strategy  strategy;

//根据 type  把实现类返回

public  BigDecimal  calRecharge(Integer channelId ,Integer  goodsId){
    return  strategy.calRechage(channelId,goodsId)
}
</code></pre><p>}</p>
<p>public  class   StrategyFactory{<br>    private  static  StrategyFactory factory  =  new  StrategyFactory();</p>
<pre><code>public  static  StrategyFactory   F
</code></pre><p>}</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>—-懒汉模式<br> 使用静态内部类实现 innerClassSingleton </p>
<p> //反射创建 实例<br> decalred<br> // InnerClassSingleton.getInstnce();获得实例</p>
<p>——饿汉模式<br> hungrySingletonTest </p>
<p> javac  -p -v  xxx .class </p>
<h1 id="代理模式-和AOP编程"><a href="#代理模式-和AOP编程" class="headerlink" title="代理模式  和AOP编程"></a>代理模式  和AOP编程</h1><p>极简介绍代理模式，绝不花里胡哨<br>假设以一个Hell接口<br>public interface IHello {</p>
<p>   void sayHello(String name);</p>
<p>   void sayGoogBye(String name);</p>
<p>}<br>和一个接口实现类<br>public class Helloimplements implements IHello {<br>    @Override<br>    public void sayHello(String name) {<br>        System.out.println(“Hello “ + name);<br>    }<br>    @Override<br>    public void sayGoogBye(String name) {<br>        System.out.println(name+” GoodBye!”);<br>    }<br>}<br>想要在 sayHello和sayGoodBye上都加入 操作日志这个动作咋办呢？<br>首先想到代理模式 传入被代理类的引用,在两个操作上都加上打印操作日志动作<br>public class StaticProxy implements IHello {</p>
<p>  private IHello iHello;</p>
<p>  public void setImpl(IHello impl){</p>
<p>  this.iHello = impl;</p>
<p>}<br>@Override</p>
<p>public void sayHello(String name) {</p>
<pre><code>System.out.println(&quot;问候之前的日志记录...&quot;);

iHello.sayHello(name);
</code></pre><p>}<br>@Override</p>
<p>public void sayGoogBye(String name) {</p>
<pre><code> System.out.println(&quot;问候之前的日志记录...&quot;);

 iHello.sayGoogBye(name);
</code></pre><p>}</p>
<p>static public void main(String[] arg) {</p>
<pre><code> Helloimplements hello = new Helloimplements();

 StaticProxy proxy = new StaticProxy();

 proxy.setImpl(hello);

 proxy.sayHello(&quot;Jerry&quot;);
</code></pre><p>  }</p>
<p>}<br>s<br>InvocationHandler是一个JDK提供的标准接口。看下面的代码：<br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;<br>public class DynaProxyHello implements InvocationHandler {<br>    private Object delegate;<br>    public Object bind(Object delegate) {<br>        this.delegate = delegate;<br>        return Proxy.newProxyInstance(<br>        this.delegate.getClass().getClassLoader(), this.delegate<br>        .getClass().getInterfaces(), this);<br>    }<br>    public Object invoke(Object proxy, Method method, Object[] args)<br>    throws Throwable {<br>        Object result = null;<br>        try {<br>            System.out.println(“问候之前的日志记录…”);<br>            // JVM通过这条语句执行原来的方法(反射机制)<br>            result = method.invoke(this.delegate, args);<br>        }<br>        catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>        return result;<br>    }<br>如何使用jdk Proxy ,直接把实现类的引用绑定到 代理类上<br>static public void main(String[] arg) {<br>    DynaProxyHello helloproxy = new DynaProxyHello();<br>    Helloimplements hello = new Helloimplements();<br>    IHello ihello = (IHello) helloproxy.bind(hello);<br>    ihello.sayHello(“Jerry”);<br>}<br>这里的 invoke 实际是由jdk生成的代理类 DynaProxyHello.invoke执行的<br>而且invoke的正确理解应该是和方法绑定的一个切点,而不是方法本身 </p>
]]></content>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2019/12/04/redis/</url>
    <content><![CDATA[<p>从 CAP理论说起<br>![CAP.png]</p>
<p>强一致性: 复制同步，<br>弱一致性 : 复制异步 </p>
<p>// Copy  On  Wirte  机制 </p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程问题</title>
    <url>/2019/12/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="多线程-几种同步问题"><a href="#多线程-几种同步问题" class="headerlink" title="多线程 几种同步问题"></a>多线程 几种同步问题</h1><p>JMM 内存模型 目的是屏蔽硬件差异</p>
<ol>
<li>synchronized关键字 </li>
</ol>
<p>2.同步代码块<br>synchronized 关键字修饰的语句块<br>所有 被修饰的语句块会被自动加上内置锁,从而实现同步</p>
<ol>
<li><p>使用特殊域变量 volatile  实现线程同步<br>a.volatile关键字为域变量的访问提供了一种免锁机制，<br>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，<br>c.因此每次使用该域就要重新计算，而不是使用寄存器中的值<br>d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量</p>
</li>
<li><p>使用重入锁  (一种可重了可递归调用的锁 ， 在外层使用后，内层仍然可以使用 ) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Bank &#123;</span><br><span class="line"></span><br><span class="line">            private int account = 100;</span><br><span class="line">            //需要声明这个锁</span><br><span class="line">            private Lock lock = new ReentrantLock();</span><br><span class="line">            public int getAccount() &#123;</span><br><span class="line">                return account;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里不再需要synchronized </span><br><span class="line">            public void save(int money) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try&#123;</span><br><span class="line">                    account += money;</span><br><span class="line">                &#125;finally&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ｝</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ReentrantLock类 是可重入,互斥,实现了Lock接口的锁<br>注：关于Lock对象和synchronized关键字的选择：<br>a.最好两个都不用，使用一种java.util.concurrent包提供的机制，<br>能够帮助用户处理所有与锁相关的代码。<br>b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码<br>c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁</p>
<ol>
<li>使用局部变量 实现线程同步<br>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，<br>副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li>
</ol>
<p>ThreadLocal 类的常用方法:<br>ThreadLocal() : 创建一个线程本地变量<br>get() : 返回此线程局部变量的当前线程副本中的值<br>initialValue() : 返回此线程局部变量的当前线程的”初始值”<br>set(T value) : 将此线程局部变量的当前线程副本中的值设置为value<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Bank&#123;</span><br><span class="line">            //使用ThreadLocal类管理共享变量account</span><br><span class="line">            private static ThreadLocal&lt;Integer&gt; account = new ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected Integer initialValue()&#123;</span><br><span class="line">                    return 100;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            public void save(int money)&#123;</span><br><span class="line">                account.set(account.get()+money);</span><br><span class="line">            &#125;</span><br><span class="line">            public int getAccount()&#123;</span><br><span class="line">                return account.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>//  ThreadLocal 设置内部 的ThreadLocalMap值  ，<br>这样对于不同的线程得到的就是不同的ThreadLocalMap</p>
<p>threadLocal 被应用于  struts2(ActionContext) 和 hibernate 中 </p>
<h1 id="线程池-ThreadPoolExcutor-原理"><a href="#线程池-ThreadPoolExcutor-原理" class="headerlink" title="线程池  ThreadPoolExcutor 原理"></a>线程池  ThreadPoolExcutor 原理</h1><p>任务  Runnable   Callable<br>任务不能 无限往仓库里提交</p>
]]></content>
  </entry>
  <entry>
    <title>JVM相关</title>
    <url>/2019/12/02/JVM%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2019/12/02/Spring/</url>
    <content><![CDATA[<h1 id="springboot-整合-springcloud"><a href="#springboot-整合-springcloud" class="headerlink" title="springboot 整合   springcloud"></a>springboot 整合   springcloud</h1><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>可以被独立部署， 更新 ，scale  , 和重启</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程 </p>
<p>编程的流程方向不同: 横向与纵向</p>
]]></content>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/2019/11/27/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>Foucus  my  conce</p>
<h1 id="AOP-思想"><a href="#AOP-思想" class="headerlink" title="AOP 思想"></a>AOP 思想</h1><p>两端毫无关联的代码 关联到一起<br>spring 注入的 AOP的代理对象<br>Join point: 拦截点，如某个业务方法。<br>Pointcut: Joinpoint 的表达式，表示拦截哪些方法。一个 Pointcut 对应多个 Joinpoint。</p>
<p>AOP切面代码织入时机：<br>1 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。<br>2 类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标类被引入应用之前增 强该目标类的字节码。AspectJ 5的加载时织入(load-time weaving，LTW)就支持以这种方式织入切面<br>3 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</p>
<h1 id="java-动态代理"><a href="#java-动态代理" class="headerlink" title="java 动态代理"></a>java 动态代理</h1><p>何谓：动态 ？就是与运行时动态对某些东西代理, (而不是对象一生成就无法改变),代理它做了其他事情</p>
<p>我所理解的代理的本质，  通过代理类对象执行 被代理对象（原对象）中的方法 ，并在原有方法前后进行增强 </p>
<p>举个例子 , 假设有程序员 JavaDevelop  </p>
<h1 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy.newProxyInstance()"></a>Proxy.newProxyInstance()</h1><p><img src="/2019/11/27/JDK动态代理/JDK动态代理.png" alt><br>为什么构造代理类  Developer时 要传入类加载和 zack 的接口<br>Developer  zackProxy   这个类不是通过implements 关键词实现的类,<br>zackProxy  被代理后生成的对象， 是通过 Developper接口字节码增强方式创建的类，属于临时构造的实现类对象 </p>
<h1 id="再来看-newProxyInstance-的-三个参数-loader-interfaces-h"><a href="#再来看-newProxyInstance-的-三个参数-loader-interfaces-h" class="headerlink" title="再来看 newProxyInstance()的 三个参数 loader, interfaces, h"></a>再来看 newProxyInstance()的 三个参数 loader, interfaces, h</h1><p>loder，选用的类加载器。因为代理的是zack，所以一般都会用加载zack的类加载器。<br>interfaces，被代理的类所实现的接口，这个接口可以是多个。<br>h，绑定代理类的一个方法。<br>loder和interfaces基本就是决定了这个类到底是个怎么样的类。而h是InvocationHandler，决定了这个代理类到底是多了什么功能。所以动态代理的内容重点就是这个InvocationHandler。</p>
<p>查看源码得知， c 作用就是，当代理对象的原本方法被调用时, 会绑定执行一个方法， 这个方法就是<br>invocationHandler 里定义的内容 ,同时会替代原本方法的结果返回 </p>
<p>InvocationHandler接收三个参数 : proxy, method ,args  </p>
]]></content>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2019/11/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>首先让我们看几个基本的消息系统术语：<br>Kafka将消息以topic为单位进行归纳。<br>将向Kafka topic发布消息的程序成为producers.<br>将预订topics并消费消息的程序成为consumer.<br>Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个broker.<br>producers通过网络将消息发送到Kafka集群，集群向消费者提供消息，如下图所示：</p>
<p>分布式发布订阅消息系统 Kafka 架构设计 <a href="http://www.linuxidc.com/Linux/2013-11/92751.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-11/92751.htm</a><br>Apache Kafka 代码实例 <a href="http://www.linuxidc.com/Linux/2013-11/92754.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-11/92754.htm</a></p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>每个分区在Kafka集群的若干服务中都有副本，这样这些持有副本的服务可以共同处理数据和请求，副本数量是可以配置的。副本使Kafka具备了容错能力。<br>每个分区都由一个服务器作为“leader”，零或若干服务器作为“followers”,leader负责处理消息的读和 写，followers则去复制leader.如果leader down了，followers中的一台则会自动成为leader。集群中的每个服务都会同时扮演两个角色：作为它所持有的一部分分区的leader，同 时作为其他分区的followers，这样集群就会据有较好的负载均衡。</p>
<h1 id="AMQ"><a href="#AMQ" class="headerlink" title="AMQ"></a>AMQ</h1>]]></content>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/2019/11/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<h1 id="向量点积-—用来算向量间夹角"><a href="#向量点积-—用来算向量间夹角" class="headerlink" title="向量点积 —用来算向量间夹角"></a>向量点积 —用来算向量间夹角</h1><p>点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影，有公式：</p>
<h1 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h1><p>在三维几何中，向量a和向量b的叉乘结果是一个向量，更为熟知的叫法是法向量，该向量垂直于a和b向量构成的平面。</p>
<h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h1><p>Cramer’s Rule</p>
<p> transpose A   转置矩阵</p>
]]></content>
  </entry>
  <entry>
    <title>服务器性能优化篇</title>
    <url>/2019/11/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/</url>
    <content><![CDATA[<h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><p>代码优化的目标是： 1、减小代码的体积。2、提高代码运行的效率。<br>1.尽量指定类，方法的 final 修饰符:<br>在java 核心API中,指定类或方法的 final修饰符, 编译器寻找内联所有的final 方法,<br>对于提升运行效率作用巨大（运行期优化）<br>2.尽量重用对象,<br> 特别是String对象,  链接字符串使用StringBuilder/StringBuffer，主要浪费在生成对象,垃圾回收上<br>3.尽可能使用 局部变量<br>4.及时关流 </p>
<ol>
<li>尽量减少对变量的重复计算<br>for (int i = 0; i &lt; list.size(); i++)<br>{…}<br>建议替换为：<br>for (int i = 0, int length = list.size(); i &lt; length; i++)<br>{…}<br>6.尽量使用懒加载 ，需要时创建<br>String str = “aaa”;if (i == 1)<br>{<br>list.add(str);<br>}</li>
</ol>
<p>建议替换为：<br>if (i == 1)<br>{<br>String str = “aaa”;</p>
<p>list.add(str);<br>}<br>7.慎用异常:<br>异常对性能不利 ,抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。<br>8、不要在循环中使用try…catch…，应该把其放在最外层。</p>
<p>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度。<br>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：<br>（1）StringBuilder() // 默认分配16个字符的空间；<br>（2）StringBuilder(int size) // 默认分配size个字符的空间；<br>（3）StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间</p>
<p>注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p>
<p>10、当复制大量数据时，使用System.arraycopy()命令。</p>
<ol>
<li>乘法和除法  使用移位操作<br>for{ val  = 0 ;  val &lt; 10000;  val +=5} {<br>a = val * 8 ;<br>b = val / 2;<br>}</li>
</ol>
<p>12、循环内不要不断创建对象引用。</p>
<p>例如：<br>for (int i = 1; i &lt;= count; i++)<br>{Object obj = new Object();<br>}</p>
<p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：<br>Object obj = null;for (int i = 0; i &lt;= count; i++) { obj = new Object(); }</p>
<p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p>
<p>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList。</p>
<p>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销。</p>
<p>15、不要将数组声明为public static final。</p>
<p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。</p>
<p>16、尽量在合适的场合使用单例。</p>
<p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：<br>（1）控制资源的使用，通过线程同步来控制资源的并发访问；<br>（2）控制实例的产生，以达到节约资源的目的；<br>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信，</p>
<p>17、尽量避免随意使用静态变量。</p>
<p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：<br>public class A<br>{<br>private static B b = new B();<br>}</p>
<p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止。</p>
<p>18、及时清除不再需要的会话。</p>
<p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。</p>
<p>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历。</p>
<p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：<br>if (list instanceof RandomAccess)<br>{ for (int i = 0; i &lt; list.size(); i++){}<br>}else{<br>Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext()){iterator.next()}<br>}</p>
<p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p>
<p>20、使用同步代码块替代同步方法。</p>
<p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p>
<p>21、将常量声明为static final，并以大写命名。</p>
<p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p>
<p>22、不要创建一些不使用的对象，不要导入一些不使用的类。</p>
<p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p>
<p>23、程序运行过程中避免使用反射。</p>
<p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p>
<p>24、使用数据库连接池和线程池。</p>
<p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。</p>
<p>25、使用带缓冲的输入输出流进行IO操作。</p>
<p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率。</p>
<p>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了。</p>
<p>27、不要让public方法中有太多的形参。</p>
<p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：<br>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合。<br>2、参数太多势必导致方法调用的出错概率增加。</p>
<p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参。</p>
<p>28、字符串变量和字符串常量equals的时候将字符串常量写在前面。</p>
<p>这是一个比较常见的小技巧了，如果有以下代码：<br>String str = “123”;<br>if (str.equals(“123”)) {…}<br>建议修改为：</p>
<p>String str = “123”;<br>if (“123”.equals(str))<br>{<br>…<br>}</p>
<p>这么做主要是可以避免空指针异常。</p>
<p>29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者。</p>
<p>平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。</p>
<p>在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：<br>int i = 2;<br>if (i == 1)</p>
<p>{<br>…<br>}else{<br>…<br>}</p>
<p>C/C++判断”i==1″不成立，所以以0表示，即false。但是如果：<br>int i = 2;if (i = 1) { … }else{ … }</p>
<p>万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p>
<p>int i = 2;if (1 == i) { … }else{ … }</p>
<p>这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p>
<p>但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p>
<p>30、不要对数组使用toString()方法。</p>
<p>看一下对数组使用toString()打印出来的是什么：<br>public static void main(String[] args)<br>{ int[] is = new int[]{1, 2, 3};<br>System.out.println(is.toString());<br>}</p>
<p>结果是：<br>[I@18a992f</p>
<p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString()方法。</p>
<p>31、不要对超出范围的基本数据类型做向下强制转型。</p>
<p>这绝不会得到想要的结果：<br>public static void main(String[] args)<br>{<br>long l = 12345678901234L;int i = (int)l;<br>System.out.println(i);<br>}</p>
<p>我们可能期望得到其中的某几位，但是结果却是：<br>1942892530</p>
<p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：<br>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p>
<p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：<br>0111 0011 1100 1110 0010 1111 1111 0010</p>
<p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：<br>1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f”。<br>2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int。</p>
<p>32、公用的集合类中不使用的数据一定要及时remove掉。</p>
<p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p>
<p>33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、<br>String.valueOf(数据)次之、数据+””最慢。</p>
<p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：<br>public static void main(String[] args)<br>{<br>int loopTime = 50000;<br>Integer i = 0; long startTime = System.currentTimeMillis();for (int j = 0; j &lt; loopTime; j++){String str = String.valueOf(i);<br>}<br>System.out.println(“String.valueOf()：” + (System.currentTimeMillis() - startTime) + “ms”);<br>startTime = System.currentTimeMillis();for (int j = 0; j &lt; loopTime; j++)<br>{<br>String str = i.toString();<br>}<br>System.out.println(“Integer.toString()：” + (System.currentTimeMillis() - startTime) + “ms”);<br>startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)<br>{<br>String str = i + “”;<br>}<br>System.out.println(“i + “”：” + (System.currentTimeMillis() - startTime) + “ms”);<br>}</p>
<p>运行结果为：<br>String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms</p>
<p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：<br>1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断。<br>2、Integer.toString()方法就不说了，直接调用了。<br>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串。</p>
<p>三者对比下来，明显是2最快、1次之、3最慢。</p>
<p>34、使用最有效率的方式去遍历Map。</p>
<p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：<br>public static void main(String[] args)<br>{<br>HashMap<string, string> hm = new HashMap<string, string>();<br>hm.put(“111”, “222”);Set<map.entry<string, string>&gt; entrySet = hm.entrySet();<br>Iterator<map.entry<string, string>&gt; iter = entrySet.iterator(); while (iter.hasNext())<br>{<br>Map.Entry<string, string> entry = iter.next();<br>System.out.println(entry.getKey() + “ “ + entry.getValue());<br>}<br>}</string,></map.entry<string,></map.entry<string,></string,></string,></p>
<p>如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet();”会比较合适一些。</p>
<p>35、对资源的close()建议分开操作。</p>
<p>意思是，比如我有这么一段代码：<br>try{<br>XXX.close();<br>YYY.close();<br>}catch (Exception e)<br>{…}</p>
<p>建议修改为：<br>try{ XXX.close(); }catch (Exception e) { … }try{ YYY.close(); }catch (Exception e) { … }</p>
<p>虽然有些麻烦，却能避免资源泄露。我想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为上面的写法之后，就保证了无论如何XXX和YYY都会被close掉。<br>//———————————————————————————————————————</p>
<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h1 id="1-数据库设计和表创建时就要考虑性能"><a href="#1-数据库设计和表创建时就要考虑性能" class="headerlink" title="1.数据库设计和表创建时就要考虑性能"></a>1.数据库设计和表创建时就要考虑性能</h1><pre><code>设计表时要注意：
</code></pre><p>表字段避免null值出现，null值很难查询优化且占用额外的索引空间，推荐默认数字0代替null。<br>——&gt;(mysql索引是可以使用索引来查询 有NULL值存在的字段<br>1.EXPLAIN select <em> from j_copy where a is null; —执行计划可以看到是否走了索引<br>)<br>尽量使用INT而非BIGINT，如果非负则加上UNSIGNED(这样数值容量会扩大一倍)，当然能使用TINYINT、SMALLINT、MEDIUM_INT更好。<br>使用枚举或整数代替字符串类型<br>尽量使用TIMESTAMP而非DATETIME<br>单表不要有太多字段，建议在20以内, （表拆分）<br>用整型来存IP地址, 即32位的无符号整数（UNSIGNED INT）， mysql 提供了转换函数,select inet_ntoa(3232235521);<br>    索引<br>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描<br>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描<br>值分布很集中的字段不适合建索引，例如”性别”这种只有两三个值的字段<br>字符字段只建前缀索引<br>字符字段**</em>不要做主键<br>不用外键，由程序保证约束<br>尽量不用UNIQUE，由程序保证约束<br>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</p>
<h1 id="2-sql的编写需要注意优化"><a href="#2-sql的编写需要注意优化" class="headerlink" title="2.sql的编写需要注意优化"></a>2.sql的编写需要注意优化</h1><p>记录一次MySQL两千万数据的大表优化解决过程，提供三种解决方案<br>使用阿里云rds for MySQL数据库(就是MySQL5.6版本)，有个用户上网记录表6个月的数据量近2000万，保留最近一年的数据量达到4000万，查询速度极慢，日常卡死。严重影响业务。我尝试解决该问题，so，有个这个日志。</p>
<p>问题概述<br>使用阿里云rds for MySQL数据库(就是MySQL5.6版本)，有个用户上网记录表6个月的数据量近2000万，保留最近一年的数据量达到4000万，查询速度极慢，日常卡死。严重影响业务。</p>
<p>问题前提：老系统，当时设计系统的人大概是大学没毕业，表设计和sql语句写的不仅仅是垃圾，简直无法直视。原开发人员都已离职，到我来维护，这就是传说中的维护不了就跑路，然后我就是掉坑的那个!!!</p>
<p>我尝试解决该问题，so，有个这个日志。</p>
<p>方案概述<br>方案一：优化现有mysql数据库。优点：不影响现有业务，源程序不需要修改代码，成本<em>*</em>。缺点：有优化瓶颈，数据量过亿就玩完了。<br>方案二：升级数据库类型，换一种100%兼容mysql的数据库。优点：不影响现有业务，源程序不需要修改代码，你几乎不需要做任何操作就能提升数据库性能，缺点：多花钱<br>方案三：一步到位，大数据解决方案，更换newsql/nosql数据库。优点：扩展性强，成本低，没有数据容量瓶颈，缺点：需要修改源程序代码<br>以上三种方案，按顺序使用即可，数据量在亿级别一下的没必要换nosql，开发成本太高。三种方案我都试了一遍，而且都形成了落地解决方案。该过程心中慰问跑路的那几个开发者一万遍 :)</p>
<p>方案一详细说明：优化现有mysql数据库<br>跟阿里云数据库大佬电话沟通 and Google解决方案 and 问群里大佬，总结如下(都是精华)：</p>
<p>1.数据库设计和表创建时就要考虑性能<br>2.sql的编写需要注意优化<br>3.分区<br>4.分表<br>5.分库<br>1、数据库设计和表创建时就要考虑性能</p>
<p>mysql数据库本身高度灵活，造成性能不足，严重依赖开发人员能力。也就是说开发人员能力高，则mysql性能高。这也是很多关系型数据库的通病，所以公司的dba通常工资巨高。</p>
<p>设计表时要注意：</p>
<p>表字段避免null值出现，null值很难查询优化且占用额外的索引空间，推荐默认数字0代替null。<br>尽量使用INT而非BIGINT，如果非负则加上UNSIGNED(这样数值容量会扩大一倍)，当然能使用TINYINT、SMALLINT、MEDIUM_INT更好。<br>使用枚举或整数代替字符串类型<br>尽量使用TIMESTAMP而非DATETIME<br>单表不要有太多字段，建议在20以内<br>用整型来存IP</p>
<p>索引<br>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描<br>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描<br>值分布很<strong><em>的字段不适合建索引，例如”性别”这种只有两三个值的字段<br>字符字段只建前缀索引<br>字符字段</em></strong>不要做主键<br>不用外键，由程序保证约束<br>尽量不用UNIQUE，由程序保证约束<br>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引<br>简言之就是使用合适的数据类型，选择合适的索引</p>
<p>选择合适的数据类型 (1)使用可存下数据的最小的数据类型，整型 &lt; date,time &lt; char,varchar &lt; blob (2)使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int类型存储时间类型，bigint类型转ip函数 (3)使用合理的字段属性长度，固定长度的表会更快。使用enum、char而不是varchar (4)尽可能使用not null定义字段 (5)尽量少用text，非用不可<em>*</em>分表 # 选择合适的索引列 (1)查询频繁的列，在where，group by，order by，on从句中出现的列 (2)where条件中&lt;，&lt;=，=，&gt;，&gt;=，between，in，以及like 字符串+通配符(%)出现的列 (3)长度小的列，索引字段越小越好，因为数据库的存储单位是页，一页中能存下的数据越多越好 (4)离散度大(不同的值多)的列，放在联合索引前面。查看离散度，通过统计不同的列值来实现，count越大，离散程度越高：</p>
<p>2、sql的编写需要注意优化<br>使用limit对查询结果的记录进行限定<br>避免select *，将需要查找的字段列出来<br>使用连接(join)来代替子查询<br>拆分大的delete或insert语句<br>可通过开启慢查询日志来找出较慢的SQL<br>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边<br>sql语句尽可能简单：一条sql只能在一个cpu运算;大语句拆小语句，减少锁时间;一条大sql可以堵死整个库<br>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内<br>不用函数和触发器，在应用程序实现<br>避免%xxx式查询<br>少用JOIN<br>使用同类型进行比较，比如用’123’和’123’比，123和123比<br>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描<br>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5<br>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大 (分页查询 )</p>
<p>数据库引擎:</p>
<pre><code>MyISAM
不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
不支持事务
不支持外键
不支持崩溃后的安全恢复
在表有读取查询的同时，支持往表中插入新纪录
支持BLOB和TEXT的前500个字符索引，支持全文索引
支持延迟更新索引，极大提升写入性能
对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用
INNODB:
1.支持行锁，采用MVCC来支持高并发  *****
2.支持事务
3.支持外键
4.支持崩溃后的安全恢复
5.不支持全文索引
总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表
但是支持事务就必须使用 innodb
</code></pre><h1 id="Mycat中间件"><a href="#Mycat中间件" class="headerlink" title="Mycat中间件"></a>Mycat中间件</h1><p>举例: db_user 逻辑库  对应  mySql中的两个 user_db实例<br>配置 {MYCAT_HOME}/conf/schema.xml 中  <schema>标签定义<br>分片表，全局表,  ER表， 非分片表 五种逻辑表类型 .</schema></p>
<h1 id="——————-分库分表——————"><a href="#——————-分库分表——————" class="headerlink" title="——————- 分库分表——————-"></a>——————- 分库分表——————-</h1><p>事务的ACID：原子，一致 ， 隔离 ，持久 </p>
<p>1.分区<br>：<br>2.分表<br>水平拆分 :<br>    横向切割 , 一张表变两张<br>垂直拆分 :<br>    纵向一切两半 ,例 : 商品表中有 原来的  商品—促销两个字段  ，分到两张新表中<br>    复杂场景下优先垂直拆分<br>分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。<br>分表分为垂直拆分和水平拆分，通常以某个字段做拆分项。比如以id字段拆分为100张表： 表名为 tableName_id%100<br>但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高!!!而且选择这个方案，都不如选择我提供的第二第三个方案的成本低!故不建议采用。<br>5.分库</p>
<p>6.冗余<br>故障转移</p>
<p>再连接<br>去中心化与中心化</p>
<h1 id="Freemarker"><a href="#Freemarker" class="headerlink" title="Freemarker"></a>Freemarker</h1><p>网页静态化技术和缓存技术的共同点都是为了减轻数据库的访问压力，但是具体的应用场景不同，缓存比较适合小规模的数据<br>，而网页静态化比较适合大规模且相对变化不太频繁的数据。另外网页静态化还有利于SEO。</p>
<p>模板文件中四种元素:<br> 1、文本，直接输出的部分<br> 2、注释，即&lt;#—…—&gt;格式不会输出<br> 3、插值（Interpolation）：即${..}部分,将使用数据模型中的部分替代输出<br> 4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。</p>
]]></content>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务解决方案</title>
    <url>/2019/11/18/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p>不使用spring  框架 , 在同一个 conneciton 中控制事务</p>
<p>CAP理论    强一致性 高可用  分区容错<br>在分布式系统中为了保证高可用，通常在不同的节点都保留数据的副本<br>大多数网站使用是AP  放弃强一致性，在一定latency之后达到最终一致性 </p>
<h1 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring  cloud"></a>spring  cloud</h1><h1 id="springcloud-netflix全家桶"><a href="#springcloud-netflix全家桶" class="headerlink" title="springcloud  netflix全家桶"></a>springcloud  netflix全家桶</h1><p>zookeeper   CP<br>eruka    AP<br>服务发现——Netflix Eureka<br>客服端负载均衡——Netflix Ribbon<br>断路器——Netflix Hystrix<br>// 保障服务稳定， 防止服务器雪崩效应<br>服务网关——Netflix Zuul<br>分布式配置——Spring Cloud Config</p>
<h1 id="spring-cloud-alibaba"><a href="#spring-cloud-alibaba" class="headerlink" title="spring  cloud alibaba"></a>spring  cloud alibaba</h1><p>几大组件 : </p>
<hr>
<p>1、事务的基本概念（ ACID ）</p>
<p>2、理解分布式事务的应用场景及面临的问题</p>
<p>3、认识分布式事务事务模型</p>
<p>4、演示 LCN 框架分布式事务管理</p>
<p>5、分布式事务解决方案（ Atomikos、LCN、TCC、MQ ）</p>
<p>6、CAP 定理 &amp; Base 理论及柔性事务</p>
<h1 id="一致性原理"><a href="#一致性原理" class="headerlink" title="一致性原理"></a>一致性原理</h1><p>1.异常  ：某节点操作不成功<br>2.网络分区 :  无法访问到某节点<br>3.应用故障 : 节点本身存在问题 </p>
<p>多条链接的事务 </p>
<h1 id="分布式服务的问题"><a href="#分布式服务的问题" class="headerlink" title="分布式服务的问题"></a>分布式服务的问题</h1><p>服务发现 （Consumer 和 Provider） ,负载均衡<br>1.传统集中式代理  ,由代理实现服务发现和 负载均衡，主要是F5和 ngix </p>
<ol>
<li>客户端嵌入代理 , 代理（服务发现和负载均衡逻辑）以客户库的形式嵌入在应用程序中 ，<br>这种模式一般需要独立的服务注册中心组件配合，服务启动时自动注册到注册中心并定期报心跳，客户端代理则发现服务并做负载均衡。<br>3.主机独立进程代理， 在同一台主机中，多个消费者公用这个代理</li>
</ol>
<h1 id="幂等性的基本概念"><a href="#幂等性的基本概念" class="headerlink" title="幂等性的基本概念"></a>幂等性的基本概念</h1><p>幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的,是与</p>
<p>为什么要设计幂等性的服务<br>幂等可以使得客户端逻辑处理变得简单，但是却以服务逻辑变得复杂为代价。满足幂等服务的需要在逻辑中至少包含两点：</p>
<p>首先去查询上一次的执行状态，如果没有则认为是第一次请求<br>在服务改变状态的业务逻辑前，保证防重复提交的逻辑</p>
<p>3.2 分布式事务解决方案<br>3.2.1 —两阶段提交协议两阶段提交协议(Two-phase Commit，2PC)<br>经常被用来实现分布式事务。一般分为协调器 C 和若干事务执行者 Si<br>两种角色，这里的事务执行者就是具体的数据库，协调器可以和事务执行器在一台机器上。</p>
<p><img src="/2019/11/18/分布式事务解决方案/TCC解决方案.png" alt><br>1) 我们的应用程序(client)发起一个开始请求到 TC;<br>2) TC 先将<prepare>消息写到本地日志，之后向所有的 Si 发起<prepare>消息。 以支付宝转账到余额宝为例，TC 给 A 的 prepare 消息是通知支付宝数据库相应账 目扣款 1 万，TC 给 B 的 prepare 消息是通知余额宝数据库相应账目增加 1w。为什 么在执行任务前需要先写本地日志，主要是为了故障后恢复用，本地日志起到现实 生活中凭证 的效果，如果没有本地日志(凭证)，出问题容易死无对证;<br>3) Si 收到<prepare>消息后，执行具体本机事务，但不会进行 commit，如果成功 返回<yes>，不成功返回<no>。同理，返回前都应把要返回的消息写到日志里，当 作凭证。<br>4) TC 收集所有执行器返回的消息，如果所有执行器都返回 yes，那么给所有执行 器发生送 commit 消息，执行器收到 commit 后执行本地事务的 commit 操作;如果 有任一个执行器返回 no，那么给所有执行器发送 abort 消息，执行器收到 abort 消息后执行事务 abort 操作。<br>注:TC 或 Si 把发送或接收到的消息先写到日志里，主要是为了故障后恢复用。如 某一 Si 从故障中恢复后，先检查本机的日志，如果已收到<commit>，则提交，如 果<abort>则回滚。如果是<yes>，则再向 TC 询问一下，确定下一步。如果什么都 没有，则很可能在<prepare>阶段 Si 就崩溃了，因此需要回滚。<br>现如今实现基于两阶段提交的分布式事务也没那么困难了，如果使用 java，那么 可以使用开源软件 atomikos(<a href="http://www.atomikos.com/)来快速实现。" target="_blank" rel="noopener">http://www.atomikos.com/)来快速实现。</a><br>优点: 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。(其 实也不能 100%保证强一致)<br>缺点: 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景， 如果分布式系统跨接口调用。 </prepare></yes></abort></commit></no></yes></prepare></prepare></prepare></p>
<h1 id="注意：但是上述两阶段提交都可以发现性能实在是太差，根本不适合-高并发的系统。"><a href="#注意：但是上述两阶段提交都可以发现性能实在是太差，根本不适合-高并发的系统。" class="headerlink" title="注意：但是上述两阶段提交都可以发现性能实在是太差，根本不适合 高并发的系统。"></a>注意：但是上述两阶段提交都可以发现性能实在是太差，根本不适合 高并发的系统。</h1><p>• 1)两阶段提交涉及多次节点间的网络通信，通信时间太长!<br>• 2)事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间 也增加好多!<br>正是由于分布式事务存在很严重的性能问题，大部分高并发服务都在避免使用，往<br>往通过其他途径来解决数据一致性问题。</p>
<ol>
<li>事务补偿机制(TCC)<br>3.2.2 事务补偿机制(TCC)<br>TCC 其实就是采用的补偿机制，其核心思想是:针对每个操作，都要注册一个与其对应 的确认和补偿(撤销)操作。它分为三个阶段:<br>Try 阶段主要是对业务系统做检测及资源预留<br>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段 时，默认 Confirm 阶段是不会出错的。即:只要 Try 成功，Confirm 一定成功。<br>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。<br>举个例子:<br>假入 A 要向 B 转账，思路大概是:<br>我们有一个本地方法，里面依次调用<br>1、首先在 Try 阶段，要先调用远程接口把 B 和 A 的钱给冻结起来。<br>2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。<br>3、如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应 的解冻方法 (Cancel)。<br>优点: 跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些 缺点:缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，<br>所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</li>
</ol>
<h1 id="3-使用消息队列-MQ-来避免分布式事务"><a href="#3-使用消息队列-MQ-来避免分布式事务" class="headerlink" title="3.使用消息队列 MQ 来避免分布式事务"></a>3.使用消息队列 MQ 来避免分布式事务</h1><p>点餐小票举例?付钱和取货动作分开,增强并发能力<br>A账户哦扣款1万, 我们只要生成一个消息（让B账户余额增加1万 ），<br>只要这个凭证消息能够保存 , 就可以拿着凭证完成最终一致性</p>
<h1 id="如何保存凭证（消息）-有两种方法"><a href="#如何保存凭证（消息）-有两种方法" class="headerlink" title="如何保存凭证（消息）,有两种方法"></a>如何保存凭证（消息）,有两种方法</h1><ol>
<li><p>业务与消息耦合的方式<br>支付宝在完成扣款的同时，同时记录消息数据，这个消息数据与业务数据保存在同一数据库实例里(消息记录表表名为 message)。<br><img src="/2019/11/18/分布式事务解决方案/业务与消息耦合.png" alt><br>上述事务能保证只要支付宝账户里被扣了钱，消息一定能保存下来。<br>当上述事务提交成功后，我们通过实时消息服务将此消息通知余额宝，余额宝处理 成功后发送回复成功消息，支付宝收到回复后删除该条消息数据。</p>
</li>
<li><p>业务与消息解耦方式上述保存消息的方式使得消息数据和业务数据紧耦合在一起，从架构上看不够优雅，而且容易诱发其他问题。为了解耦，可以采用以下方式。<br>1)支付宝在扣款事务提交之前，向实时消息服务请求发送消息，实时消息服务只 记录消息数据，而不真正发送，只有消息发送成功后才会提交事务;<br>2)当支付宝扣款事务被提交成功后，向实时消息服务确认发送。只有在得到确认 发送指令后，实时消息服务才真正发送该消息;<br>3)当支付宝扣款事务提交失败回滚后，向实时消息服务取消发送。在得到取消发 送指令后，该消息将不会被发送;<br>4)对于那些未确认的消息或者取消的消息，需要有一个消息状态确认系统定时去 支付宝系统查询这个消息的状态并进行更新。为什么需要这一步骤，举个例子:假设在第 2 步支付宝扣款事务被成功提交后，系统挂了，此时消息状态并未被更新为 “确认发送”，从而导致消息不能被发送。<br>优点:消息数据独立存储，降低业务系统与消息系统间的耦合; 缺点:一次消息发送需要两次请求;业务处理服务需要实现消息状态回查接口。</p>
</li>
</ol>
<p>3.如何解决消息重复投递的问题还有一个很严重的问题就是消息重复投递，以我们支付宝转账到余额宝为例，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加 2 万而不是 1 万了。<br>为什么相同的消息会被重复投递?比如余额宝处理完消息 msg 后，发送了处理成功 的消息给支付宝，正常情况下支付宝应该要删除消息 msg，但如果支付宝这时候悲 剧的挂了，重启后一看消息 msg 还在，就会继续发送消息 msg。<br>解决方法很简单，在余额宝这边增加消息应用状态表(message_apply)，通俗来 说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先 去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到<br> 才执行，同时插入到消息应用状态表(同一事务)。</p>
<p><img src="/2019/11/18/分布式事务解决方案/消息应用状态表.png" alt></p>
]]></content>
  </entry>
  <entry>
    <title>索引优化与B+tree</title>
    <url>/2019/11/18/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8EB-tree/</url>
    <content><![CDATA[<p>分库分表， sql优化 ， 存储过程 ,  读写分离  </p>
<h1 id="数据库语句优化的方法及原理"><a href="#数据库语句优化的方法及原理" class="headerlink" title="数据库语句优化的方法及原理"></a>数据库语句优化的方法及原理</h1><p>3、MySQL常用SQL查询语句优化方法, 使用explain 执行计划可以看到是否走了索引 </p>
<p>⑴、应尽量避免在where子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
<p>⑵、对查询进行优化，应尽量避免全表扫描，首先考虑在where及order by涉及的列上建立索引。</p>
<p>⑶、应尽量避免在where子句中字段进行null值判断，否则引擎将放弃使用索引而进行全表扫描。</p>
<p>⑷、OR前后两个条件都要有索引整个SQL才会使用索引，只要有一个条件没索引整个SQL就不适用索引。</p>
<p>⑸、MySQL将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个O(log n)复杂度的操作，等价地转换成OR查询的复杂度为O(n)，对于IN()列表中大量取值的时候，MySQL的处理速度将会更快。</p>
<p>⑹、左模糊查询将导致全表扫描。  %xxxx</p>
<p>⑺、不要在where子句中对字段进行函数、表达式操作，这样将导致全表扫描。</p>
<p>⑻、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，应尽可能的让字段顺序与索引顺序一致。</p>
<p>⑼、避免隐式类型转换，如字符串应加单引号，否则会导致全部扫描———————</p>
<p>⑽、任何地方都不要使用select <em> from t，用具体的字段列表代替“</em>”，不要返回用不到的任何字段，这样会导致回表。</p>
<p>⑾、尽量避免向客户端返回大数据量，若数据量过大，应该<br>//——————b+tree———————————-<br><img src="/2019/11/18/索引优化与B-tree/典型的B+tree.png" alt><br>如图：其中非叶子节点存储的是key值 ，叶子节点的data 一般存储的是数据节点的地址值</p>
<h1 id="查询key值等于30的过程"><a href="#查询key值等于30的过程" class="headerlink" title="查询key值等于30的过程"></a>查询key值等于30的过程</h1><p>1) 读取根节点 Page 0，将其中的信息导入内存，根据二分查找算法，发现 15 &lt; 30 &lt; 56，因此我们其指向Page 1</p>
<p>2) 读取 Page 1内容，导入内存，根据算法发现 20 &lt; 30 &lt; 49,找到Page 3</p>
<p>3)读取Page 3 内容，根据二分查找，找到KEY = 30的记录</p>
<p>分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。由于是B+Tree在内存中<br>有序表结构，可以利用二分查找提高效率。至于IO操作是影响整个B树查找效率的决定因素。</p>
<h1 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h1><p>当我们用MySQL InnoDB引擎创建表的时候，必须有一个且只能有一个主键，如果没有显式指定，<br>则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。<br>除了主键外，还可以建N个索引。这些主键和索引其实就是B+Tree。</p>
<p>新建表就是新建了一个按照主键为KEY，按照主键排序的B+Tree 结构，我们称之为聚集索引 </p>
<p>新建索引时，也是新建了一个以索引字段为KEY,且按照索引字段排序的B+Tree结构，我们称之为非聚集索引 </p>
<p>这2种索引在结构上是一样的，都是B+Tree，**不同的是叶节点里存储的数据。<br>区别 ：<color="blue">聚集索引叶节点存储的是原始数据，而非聚集索引叶节点存储的是主键的值。</color="blue"></p>
<p>【图1】为聚集索引 【图2】为非聚集索引。</p>
<p>下面我们新建一个表table1：主键是 id，一个索引name ,来举例说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table1` (</span><br><span class="line"></span><br><span class="line">  `id` int(11) NOT NULL COMMENT &apos;唯一标识&apos;,</span><br><span class="line"></span><br><span class="line">  `age` int(11) DEFAULT NULL COMMENT &apos;年龄&apos;,</span><br><span class="line"></span><br><span class="line">  `name` char(10) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;姓名&apos;,</span><br><span class="line"></span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line"></span><br><span class="line">  KEY `idx_name` (`name`)</span><br><span class="line"></span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure>
<p>表结构:<br>字段 | 类型  |  PK |  备注<br>Id|  int   |  Y |  标识<br>Age| int  | N | 年龄<br>Name  |  char(10) |  N  | 姓名 </p>
<p>表内容:<br>Id |  Age | Name<br>15  |  34  |  Bob<br>18  |   77  | Alice<br>20  |   5   |   Jim<br><img src="/2019/11/18/索引优化与B-tree/聚集索引.png" alt><br><img src="/2019/11/18/索引优化与B-tree/非聚集索引.png" alt><br>当我们新建表 table1 ,并插入数据后, 会建立主键索引<br>Select * from table1 where id =15 ： 直接查找聚集索引即可</p>
<p>Select * from table1 where name = “Tom” ： 先在非聚集索引(图3)中查找出Tom所对应的主键值为49，<br>然后查找在聚集索引(图2)中查找主键为49的记录</p>
<h1 id="强烈建议自增主键作为-id主键的原因"><a href="#强烈建议自增主键作为-id主键的原因" class="headerlink" title="强烈建议自增主键作为 id主键的原因"></a>强烈建议自增主键作为 id主键的原因</h1><p>我的理解：<br>Q: 自增ID，GUID的作为主键的区别<br>W: 除了自增ID占用空间小，GUID占用空间大之外，最主要的区别是 自增ID的插入速度大大快于GUID的插入速度，因为自增ID的ID是排序好的，意味着其在插入的过程中，不会引起页分裂，而GUID恰恰相反，正因为其是随机生成的，每插入一条数据都会引起页分裂，造成数据大量的移动，消耗大量的磁盘IO。</p>
<p>结论是：insert 速度 自增ID 明显快于 GUID，其他操作效率一样。建议用自增ID，或者自己生成的带有自增性质的ID。</p>
<p>Q: 字节数 &gt; PAGE_SIZE的字段是如何存储的？</p>
<p>W: 当字段字节数 &gt; PAGE_SIZE是，除了在原记录所在的Leaf Page中保留部分内容外，过多的内容会溢出到 Overflow Page中。</p>
<p>Q: 为什么数据库表的字段个数都有限制?</p>
<p>W:</p>
<p>这是MySQL Innodb 给出的一些限制，从上面可以看出，表的最大字段个数为1000。<br>那为什么会有这样的限制呢，</p>
<p>我的理解是：因为一个页是有大小限制的(mysql 为 16K)，为了保证每个页至少有1条(或N条)记录，必须限制字段的数量，如果字段数量太多，这条记录的空间超过了 16K，这时用btree这样的结构是无法存储的。</p>
<p>最后我们再扩展一下，大家有没有想过，亿条记录在数据库中是个什么概念? 我们不妨基于上面所说的算一下。</p>
<p>一个PAGE 在磁盘上为 16K，每条记录占用100 个字节的话，16 * 1024 /100  == 163.84，抛去PAGE_HEADER等内容，我们假设1个页可以存130条记录的，那么3层BTree，则可以存储 130^3 百万数量的级别，4层BTree,则可以存储亿级数量，5层BTree将达到百亿数据量的级别。</p>
<p>所以对于有上亿条数据的Table来说，我们只需3次 磁盘IO即可查找到，速度还是很快<br>// 聚簇索引  ——更新成本高<br>和物理存储结构一致的一种索引，一个表<br>create   Noncluster index  XX-XX  on  Table(Name)</p>
<p>//非聚簇索引(二次查询 ) </p>
]]></content>
  </entry>
  <entry>
    <title>网络通信相关</title>
    <url>/2019/11/11/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="tcp-的-keep-alive-心跳检测机制"><a href="#tcp-的-keep-alive-心跳检测机制" class="headerlink" title="tcp 的 keep alive 心跳检测机制"></a>tcp 的 keep alive 心跳检测机制</h1><p> keepalive就是为了监测链接可用性， tcp_keepalive_time ,   tcp_keepalive_intvl  ,   tcp_keepalive_probes<br>客户端和服务端三次握手后 ， 客户端和服务端都处于 ESTABLISH状态 , 这个时候正常的 PSH和 ACK交互<br>一旦一方服务中断, 另一方在距离上次的PSH时间 tcp_keepalive_time 发现对方未发送数据，则开始心跳检测<br>发送一个psh的 空心跳包, 报数据为空 ，但是头部的数据和标识和正常包一样<br>如果这个包获取带的是RST返回的话 , </p>
<h1 id="1、BIO编程"><a href="#1、BIO编程" class="headerlink" title="1、BIO编程"></a>1、BIO编程</h1><pre><code>1.1、传统的BIO编程
</code></pre><p>网络编程的基本模型是C/S模型，即两个进程间的通信。简单描述就是并发请求会使得服务器，开启对应相应链接的很多编程,效率低下<br>服务端提供IP和监听端口，客户端通过连接操作想服务端监听的地址发起连接请求，通过三次握手连接，如果连接成功建立，双方就可以通过套接字进行通信。<br>传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。 </p>
<p>简单的描述一下BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个<br>客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型。<br>每个服务器端处理请求的线程代码,服务端将以多线程形式启动此 Handler<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.anxpp.io.calculator.bio;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"> </span><br><span class="line">import com.anxpp.io.utils.Calculator;</span><br><span class="line">/**</span><br><span class="line"> * 客户端线程</span><br><span class="line"> * @author yangtao__anxpp.com</span><br><span class="line"> */</span><br><span class="line">public class ServerHandler implements Runnable&#123;</span><br><span class="line">	private Socket socket;</span><br><span class="line">	public ServerHandler(Socket socket) &#123;</span><br><span class="line">		this.socket = socket;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		BufferedReader in = null;</span><br><span class="line">		PrintWriter out = null;</span><br><span class="line">		try&#123;</span><br><span class="line">			in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">			out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">			String expression;</span><br><span class="line">			String result;</span><br><span class="line">			while(true)&#123;</span><br><span class="line">				//通过BufferedReader读取一行</span><br><span class="line">				//如果已经读到输入流尾部，返回null,退出循环</span><br><span class="line">				//如果得到非空值，就尝试计算结果并返回</span><br><span class="line">				if((expression = in.readLine())==null) break;</span><br><span class="line">				System.out.println(&quot;服务器收到消息：&quot; + expression);</span><br><span class="line">				try&#123;</span><br><span class="line">					result = Calculator.cal(expression).toString();</span><br><span class="line">				&#125;catch(Exception e)&#123;</span><br><span class="line">					result = &quot;计算错误：&quot; + e.getMessage();</span><br><span class="line">				&#125;</span><br><span class="line">				out.println(result);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;catch(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			//一些必要的清理工作</span><br><span class="line">			if(in != null)&#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					in.close();</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				in = null;</span><br><span class="line">			&#125;</span><br><span class="line">			if(out != null)&#123;</span><br><span class="line">				out.close();</span><br><span class="line">				out = null;</span><br><span class="line">			&#125;</span><br><span class="line">			if(socket != null)&#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					socket.close();</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				socket = null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-伪异步-，其实就是服务端用线程池管理了多线程"><a href="#2-伪异步-，其实就是服务端用线程池管理了多线程" class="headerlink" title="2.伪异步 ，其实就是服务端用线程池管理了多线程"></a>2.伪异步 ，其实就是服务端用线程池管理了多线程</h1><p>   为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程（需要了解更多请参考前面提供的文章），<br>   实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。<br>总结：<br>    serverHandler 和阻塞IO一样 ，只不过服务端是使用线程池管理这些链接线程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.anxpp.io.calculator.bio;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">/**</span><br><span class="line"> * BIO服务端源码__伪异步I/O</span><br><span class="line"> * @author yangtao__anxpp.com</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public final class ServerBetter &#123;</span><br><span class="line">	//默认的端口号</span><br><span class="line">	private static int DEFAULT_PORT = 12345;</span><br><span class="line">	//单例的ServerSocket</span><br><span class="line">	private static ServerSocket server;</span><br><span class="line">	//线程池 懒汉式的单例</span><br><span class="line">	private static ExecutorService executorService = Executors.newFixedThreadPool(60);</span><br><span class="line">	//根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值</span><br><span class="line">	public static void start() throws IOException&#123;</span><br><span class="line">		//使用默认值</span><br><span class="line">		start(DEFAULT_PORT);</span><br><span class="line">	&#125;</span><br><span class="line">	//这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了</span><br><span class="line">	public synchronized static void start(int port) throws IOException&#123;</span><br><span class="line">		if(server != null) return;</span><br><span class="line">		try&#123;</span><br><span class="line">			//通过构造函数创建ServerSocket</span><br><span class="line">			//如果端口合法且空闲，服务端就监听成功</span><br><span class="line">			server = new ServerSocket(port);</span><br><span class="line">			System.out.println(&quot;服务器已启动，端口号：&quot; + port);</span><br><span class="line">			//通过无线循环监听客户端连接</span><br><span class="line">			//如果没有客户端接入，将阻塞在accept操作上。</span><br><span class="line">			while(true)&#123;</span><br><span class="line">				Socket socket = server.accept();</span><br><span class="line">				//当有新的客户端接入时，会执行下面的代码</span><br><span class="line">				//然后创建一个新的线程处理这条Socket链路</span><br><span class="line">				executorService.execute(new ServerHandler(socket));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			//一些必要的清理工作</span><br><span class="line">			if(server != null)&#123;</span><br><span class="line">				System.out.println(&quot;服务器已关闭。&quot;);</span><br><span class="line">				server.close();</span><br><span class="line">				server = null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-NIO-新思路"><a href="#3-NIO-新思路" class="headerlink" title="3.NIO, 新思路"></a>3.NIO, 新思路</h1><p>Non-block I/O，即非阻塞I/O，因为这样叫，更能体现它的特点。而下文中的NIO，不是指整个新的I/O库，而是非阻塞I/O。</p>
<p>NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的<strong>SocketChannel和ServerSocketChannel</strong>两种不同的套接字通道实现。<br>新增的着两种通道都支持阻塞和非阻塞两种模式。<br>阻塞模式使用就像传统中的支持一样, 不好<br>非阻塞模式</p>
<p>NIO的几个关键名词:<br>一 、Buffer:缓冲区  ，  实际上就是一个数组 , 并提供结构化访问及维护了读写位置信息<br>具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、<br>FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。<br>二 、通道 Channel<br>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。<br>底层的操作系统的通道一般都是全双工(就是既能发也能收)的，所以全双工的Channel比流能更好的映射底层操作系统的API。<br>Channel主要分两大类：<br>    SelectableChannel：用户网络读写<br>    FileChannel：用于文件操作<br>    后面代码会涉及的ServerSocketChannel和SocketChannel都是SelectableChannel的子类<br>Channel:它代表了一个用于连接到实体如硬件设备、文件、网络套接字或程序组件,能够执行一个或多个不同的 I/O 操作（例如读或写）的开放连接。<br>2.4、多路复用器 Selector<br>Selector是Java  NIO 编程的基础。<br>Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。<br>一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。<br>Futrue </p>
<h1 id="NIO-效率相较于BIO高的主要原因是："><a href="#NIO-效率相较于BIO高的主要原因是：" class="headerlink" title="NIO 效率相较于BIO高的主要原因是："></a>NIO 效率相较于BIO高的主要原因是：</h1><p>   Processor线程不会 1：1客户端 且没有连接就阻塞<br>   Processor 在处理 read 或 wirte时非阻塞,立即返回的 </p>
<h1 id="NIO创建的Server源码："><a href="#NIO创建的Server源码：" class="headerlink" title="NIO创建的Server源码："></a>NIO创建的Server源码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.anxpp.io.calculator.nio;</span><br><span class="line">public class Server &#123;</span><br><span class="line">	private static int DEFAULT_PORT = 12345;</span><br><span class="line">	private static ServerHandle serverHandle;</span><br><span class="line">	public static void start()&#123;</span><br><span class="line">		start(DEFAULT_PORT);</span><br><span class="line">	&#125;</span><br><span class="line">	public static synchronized void start(int port)&#123;</span><br><span class="line">		if(serverHandle!=null)</span><br><span class="line">			serverHandle.stop();</span><br><span class="line">		serverHandle = new ServerHandle(port);</span><br><span class="line">		new Thread(serverHandle,&quot;Server&quot;).start();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		start();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ServerHandler"><a href="#ServerHandler" class="headerlink" title="ServerHandler"></a>ServerHandler</h1><p>public class ServerHandle implements Runnable{<br>    private Selector selector;<br>    private ServerSocketChannel serverChannel;<br>    private volatile boolean started;<br>    /**</p>
<pre><code> * 构造方法
 * @param port 指定要监听的端口号
 */
public ServerHandle(int port) {
    try{
        //创建选择器
        selector = Selector.open();
        //打开监听通道
        serverChannel = ServerSocketChannel.open();
        //如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式
        serverChannel.configureBlocking(false);//开启非阻塞模式
        //绑定端口 backlog设为1024,  此处backlog 是
        serverChannel.socket().bind(new InetSocketAddress(port),1024);
        //监听客户端连接请求
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        //标记服务器已开启
        started = true;
        System.out.println(&quot;服务器已启动，端口号：&quot; + port);
    }catch(IOException e){
        e.printStackTrace();
        System.exit(1);
    }
}
public void stop(){
    started = false;
}
@Override
public void run() {
    //循环遍历selector
    while(started){
        try{
            //无论是否有读写事件发生，selector每隔1s被唤醒一次
            selector.select(1000);
            //阻塞,只有当至少一个注册的事件发生的时候才会继续.
</code></pre><p>//                selector.select();<br>                Set<selectionkey> keys = selector.selectedKeys();<br>                Iterator<selectionkey> it = keys.iterator();<br>                SelectionKey key = null;<br>                while(it.hasNext()){<br>                    key = it.next();<br>                    it.remove();<br>                    try{<br>                        handleInput(key);<br>                    }catch(Exception e){<br>                        if(key != null){<br>                            key.cancel();<br>                            if(key.channel() != null){<br>                                key.channel().close();<br>                            }<br>                        }<br>                    }<br>                }<br>            }catch(Throwable t){<br>                t.printStackTrace();<br>            }<br>        }<br>        //selector关闭后会自动释放里面管理的资源<br>        if(selector != null)<br>            try{<br>                selector.close();<br>            }catch (Exception e) {<br>                e.printStackTrace();<br>            }<br>    }<br>    private void handleInput(SelectionKey key) throws IOException{<br>        if(key.isValid()){<br>            //处理新接入的请求消息<br>            if(key.isAcceptable()){<br>                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();<br>                //通过ServerSocketChannel的accept创建SocketChannel实例<br>                //完成该操作意味着完成TCP三次握手，TCP物理链路正式建立<br>                SocketChannel sc = ssc.accept();<br>                //设置为非阻塞的<br>                sc.configureBlocking(false);<br>                //注册为读<br>                sc.register(selector, SelectionKey.OP_READ);<br>            }<br>            //读消息<br>            if(key.isReadable()){<br>                SocketChannel sc = (SocketChannel) key.channel();<br>                //创建ByteBuffer，并开辟一个1M的缓冲区<br>                ByteBuffer buffer = ByteBuffer.allocate(1024);<br>                //读取请求码流，返回读取到的字节数<br>                int readBytes = sc.read(buffer);<br>                //读取到字节，对字节进行编解码<br>                if(readBytes&gt;0){<br>                    //将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作<br>                    buffer.flip();<br>                    //根据缓冲区可读字节数创建字节数组<br>                    byte[] bytes = new byte[buffer.remaining()];<br>                    //将缓冲区可读字节数组复制到新建的数组中<br>                    buffer.get(bytes);<br>                    String expression = new String(bytes,”UTF-8”);<br>                    System.out.println(“服务器收到消息：” + expression);<br>                    //处理数据<br>                    String result = null;<br>                    try{<br>                        result = Calculator.cal(expression).toString();<br>                    }catch(Exception e){<br>                        result = “计算错误：” + e.getMessage();<br>                    }<br>                    //发送应答消息<br>                    doWrite(sc,result);<br>                }<br>                //没有读取到字节 忽略<br>//                else if(readBytes==0);<br>                //链路已经关闭，释放资源<br>                else if(readBytes&lt;0){<br>                    key.cancel();<br>                    sc.close();<br>                }<br>            }<br>        }<br>    }<br>    //异步发送应答消息<br>    private void doWrite(SocketChannel channel,String response) throws IOException{<br>        //将消息编码为字节数组<br>        byte[] bytes = response.getBytes();<br>        //根据数组容量创建ByteBuffer<br>        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);<br>        //将字节数组复制到缓冲区<br>        writeBuffer.put(bytes);<br>        //flip操作<br>        writeBuffer.flip();<br>        //发送缓冲区的字节数组<br>        channel.write(writeBuffer);<br>        //<em>**</em>此处不含处理“写半包”的代码<br>    }</selectionkey></selectionkey></p>
]]></content>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2019/11/07/docker/</url>
    <content><![CDATA[<h1 id="云原生概念-与-service-mesh"><a href="#云原生概念-与-service-mesh" class="headerlink" title="云原生概念 与  service-mesh"></a>云原生概念 与  service-mesh</h1><h1 id="docker-与-K8s"><a href="#docker-与-K8s" class="headerlink" title="docker 与 K8s"></a>docker 与 K8s</h1><p>docker是一种轻量级的虚拟化，类似于沙箱<br>build ,ship, run<br>搭建、发送、运行</p>
<h1 id="docker的三大核心概念-Im-书包里的镜像-Container（建好的房子）-Repository-（书包）"><a href="#docker的三大核心概念-Im-书包里的镜像-Container（建好的房子）-Repository-（书包）" class="headerlink" title="docker的三大核心概念 ,  Im(书包里的镜像 )  , Container（建好的房子） , Repository （书包）"></a>docker的三大核心概念 ,  Im(书包里的镜像 )  , Container（建好的房子） , Repository （书包）</h1><h1 id="kubernetes-含义是舵手或领航员"><a href="#kubernetes-含义是舵手或领航员" class="headerlink" title="kubernetes  含义是舵手或领航员"></a>kubernetes  含义是舵手或领航员</h1><p>一个 Master节点 ,age一群Node节点 , Master 负责管理和控制， Node工作负载节点<br><img src="/2019/11/07/docker/k8s.png" alt><br>Master节点包括API Server、Scheduler、Controller manager、etcd。<br><img src="/2019/11/07/docker/Master.png" alt><br>Node节点<br><img src="/2019/11/07/docker/Node.png" alt></p>
<p>一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口</p>
<h1 id="IDEA使用事项"><a href="#IDEA使用事项" class="headerlink" title="IDEA使用事项"></a>IDEA使用事项</h1><p>（1）war模式这种可以称之为是发布模式，看名字也知道，这是先打成war包，再发布；<br>（2）war exploded模式是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。</p>
<h1 id="linux-脚本与常用命令"><a href="#linux-脚本与常用命令" class="headerlink" title="linux 脚本与常用命令"></a>linux 脚本与常用命令</h1><pre><code>使用 yum安装的软件 ,查找路径
rpm  -qa  | grep  redis 
查找安装包的路径  rpm -ql redis-3.2.10-2.el7.x86_64
</code></pre><p>// 查找文件夹和文件<br>find   /查找范围    -name  ‘关键字’  -type d</p>
<p>//输出到文件<br>$ ls &gt; ls.txt    ＃或者 ls—&gt;ls.txt    ＃把ls命令的运行结果保存到文件ls.txt中</p>
<h1 id="Docker-使用的基本命令"><a href="#Docker-使用的基本命令" class="headerlink" title="Docker  使用的基本命令"></a>Docker  使用的基本命令</h1><p>//查询所有容器,包括已经停止的<br>docker ps -a<br>// 启动一个已经存在的容器<br>docker  start  d33bc8d7387a<br>//docker启动 mysql 命令<br>$ docker run  —restart=always  —name  mingxie-mysql -p 32xxx:3306 -e MYSQL_ROOT_PASSWORD=1234 -d mysql:latest<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--name 后面的是docker容器名</span><br><span class="line">-p 32xxx:3306 这里需要注意 `32xxx` 是你**链接mysql的时候的`Port`。**</span><br><span class="line">-e MYSQL_ROOT_PASSWORD 是设置mysql的root账号密码</span><br><span class="line">-d mysql 是你的镜像标签</span><br></pre></td></tr></table></figure></p>
<h1 id="在shell中访问mysql"><a href="#在shell中访问mysql" class="headerlink" title="在shell中访问mysql"></a>在shell中访问mysql</h1><p>//docker exec -it 容器id bash<br>docker exec -it mingxie-mysql bash</p>
<p>root@7c289aa0ca95:/#<br>mysql -uroot -p -h localhost<br>Enter password:<br>输入密码即可。<br>在shell中访问mysql日志<br>$ docker logs mingxie-mysql<br>// docker 启动<br>docker run —name d33bc8d7387a  -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</p>
<h1 id="使用-dokcerfile-定制自己的镜像"><a href="#使用-dokcerfile-定制自己的镜像" class="headerlink" title="使用 dokcerfile 定制自己的镜像"></a>使用 dokcerfile 定制自己的镜像</h1><ol>
<li>from   scratch </li>
<li><h1 id="设置docker-容器开机自启动"><a href="#设置docker-容器开机自启动" class="headerlink" title="设置docker 容器开机自启动"></a>设置docker 容器开机自启动</h1>sudo docker run -t -p 80:80 registry.cn-hangzhou.aliyuncs.com/XXX/Name:[镜像版本号]<br>docekr ps 查看下容器id: 81bcb97c4f5e<br>$ docker update —restart=always 81bcb97c4f5e</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>秒杀方案</title>
    <url>/2019/11/05/%E7%94%B5%E5%95%86%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>来源：<a href="https://juejin.im/post/5d84e21f6fb9a06ac8248149" target="_blank" rel="noopener">https://juejin.im/post/5d84e21f6fb9a06ac8248149</a></p>
<h1 id="高并发-到底并发的是什么"><a href="#高并发-到底并发的是什么" class="headerlink" title="高并发 到底并发的是什么"></a>高并发 到底并发的是什么</h1><h1 id="论淘宝架构-与-12306网站"><a href="#论淘宝架构-与-12306网站" class="headerlink" title="论淘宝架构 与 12306网站"></a>论淘宝架构 与 12306网站</h1><p>Github代码地址：<br><a href="https://github.com/GuoZhaoran/spikeSystem" target="_blank" rel="noopener">https://github.com/GuoZhaoran/spikeSystem</a></p>
<p>大型高并发系统架构</p>
<p>高并发的系统架构都会采用分布式集群部署，服务上层有着层层负载均衡，并提供各种容灾手段（双火机房、节点容错、服务器灾备等）保证系统的高可用，流量也会根据不同的负载能力和配置策略均衡到不同的服务器上。</p>
<p>下边是一个简单的示意图：<br><img src="/2019/11/05/电商架构/高并发系统架构.png" alt></p>
<p>负载均衡简介</p>
<p>上图中描述了用户请求到服务器经历了三层的负载均衡，下边分别简单介绍一下这三种负载均衡。</p>
<p>①OSPF（开放式最短链路优先）是一个内部网关协议（Interior Gateway Protocol，简称 IGP）</p>
<p>OSPF 通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，OSPF 会自动计算路由接口上的 Cost 值，但也可以通过手工指定该接口的 Cost 值，手工指定的优先于自动计算的值。</p>
<p>OSPF 计算的 Cost，同样是和接口带宽成反比，带宽越高，Cost 值越小。到达目标相同 Cost 值的路径，可以执行负载均衡，最多 6 条链路同时执行负载均衡。</p>
<p>②LVS （Linux Virtual Server）</p>
<p>它是一种集群（Cluster）技术，采用 IP 负载均衡技术和基于内容请求分发技术。</p>
<p>调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。</p>
<p>③Nginx</p>
<p>想必大家都很熟悉了，是一款非常高性能的 HTTP 代理/反向代理服务器，服务开发中也经常使用它来做负载均衡。</p>
<p>Nginx 实现负载均衡的方式主要有三种：</p>
<p>轮询</p>
<p>加权轮询</p>
<p>IP Hash 轮询</p>
<p>下面我们就针对 Nginx 的加权轮询做专门的配置和测试。</p>
<p>Nginx 加权轮询的演示</p>
<p>Nginx 实现负载均衡通过 Upstream 模块实现，其中加权轮询的配置是可以给相关的服务加上一个权重值，配置的时候可能根据服务器的性能、负载能力设置相应的负载。</p>
<p>下面是一个加权轮询负载的配置，我将在本地的监听 3001-3004 端口，分别配置 1，2，3，4 的权重：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置负载均衡</span><br><span class="line">    upstream load_rule &#123;</span><br><span class="line">       server 127.0.0.1:3001 weight=1;</span><br><span class="line">       server 127.0.0.1:3002 weight=2;</span><br><span class="line">       server 127.0.0.1:3003 weight=3;</span><br><span class="line">       server 127.0.0.1:3004 weight=4;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  load_balance.com www.load_balance.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">       proxy_pass http://load_rule;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 Hash 结构存储总库存和总销量的信息，用户请求过来时，判断总销量是否大于库存，然后返回相关的 Bool 值。</p>
<p>在启动服务之前，我们需要初始化 Redis 的初始库存信息：<br>hmset ticket_hash_key “ticket_total_nums” 10000 “ticket_sold_nums” 0</p>
<p>响应用户信息</p>
<p>我们开启一个 HTTP 服务，监听在一个端口上：</p>
<p>package main<br>…<br>func main() {<br>    http.HandleFunc(“/buy/ticket”, handleReq)<br>    http.ListenAndServe(“:3005”, nil)<br>}</p>
<p>总结回顾</p>
<p>总体来说，秒杀系统是非常复杂的。我们这里只是简单介绍模拟了一下单机如何优化到高性能，集群如何避免单点故障，保证订单不超卖、不少卖的一些策略</p>
<p>完整的订单系统还有订单进度的查看，每台服务器上都有一个任务，定时的从总库存同步余票和库存信息展示给用户，还有用户在订单有效期内不支付，释放订单，补充到库存等等。</p>
<p>我们实现了高并发抢票的核心逻辑，可以说系统设计的非常的巧妙，巧妙的避开了对 DB 数据库 IO 的操作。</p>
<p>对 Redis 网络 IO 的高并发请求，几乎所有的计算都是在内存中完成的，而且有效的保证了不超卖、不少卖，还能够容忍部分机器的宕机。</p>
<p>我觉得其中有两点特别值得学习总结：</p>
<p>①负载均衡，分而治之</p>
<p>通过负载均衡，将不同的流量划分到不同的机器上，每台机器处理好自己的请求，将自己的性能发挥到极致。</p>
<p>这样系统的整体也就能承受极高的并发了，就像工作的一个团队，每个人都将自己的价值发挥到了极致，团队成长自然是很大的。</p>
<p>②合理的使用并发和异步</p>
<p>自 Epoll 网络架构模型解决了 c10k 问题以来，异步越来越被服务端开发人员所接受，能够用异步来做的工作，就用异步来做，在功能拆解上能达到意想不到的效果。</p>
<p>这点在 Nginx、Node.JS、Redis 上都能体现，他们处理网络请求使用的 Epoll 模型，用实践告诉了我们单线程依然可以发挥强大的威力。</p>
<p>服务器已经进入了多核时代，Go 语言这种天生为并发而生的语言，完美的发挥了服务器多核优势，很多可以并发处理的任务都可以使用并发来解决，比如 Go 处理 HTTP 请求时每个请求都会在一个 Goroutine 中执行。</p>
<p>总之，怎样合理的压榨 CPU，让其发挥出应有的价值，是我们一直需要探索学习的方向。</p>
<h1 id="经典的分布式电商系统架构"><a href="#经典的分布式电商系统架构" class="headerlink" title="经典的分布式电商系统架构"></a>经典的分布式电商系统架构</h1><p><img src="/2019/11/05/电商架构/电商系统架构图.png" alt></p>
<p><sub>设置下标</sub><br>Service 层主要由几大模块组成:</p>
<pre><code>* 商品后台管理模块 
* ES搜索服务
* 商品详情页展示
* 商城首页展示
* 用户管理CRM模块
* 购物车
* 订单服务
* 秒杀服务
</code></pre><p><font size="3" color="green" fece="微软雅黑">————-分割线——————</font></p>
<h1 id="经典的购物车实现方案"><a href="#经典的购物车实现方案" class="headerlink" title="经典的购物车实现方案"></a>经典的购物车实现方案</h1><p>1.1. 购物车常见实现方式<br>传统的做法是使用关系型数据库，比如mysql，建立一个cat购物车表，把相关的购物车产品信息都放到数据库里面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><p>try{}  catch {} 打日志 ，做日志补偿  </p>
]]></content>
      <tags>
        <tag>电商相关</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop集群</title>
    <url>/2019/10/30/hadoop%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>我所使用的IDEA实用插件</title>
    <url>/2019/10/30/%E6%88%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="File—-gt-Settings-安装-JetBrain-插件"><a href="#File—-gt-Settings-安装-JetBrain-插件" class="headerlink" title="File—-&gt; Settings 安装 JetBrain 插件"></a>File—-&gt; Settings 安装 JetBrain 插件</h1><ol>
<li>activate-power-mode  和 Power  mode II<br><img src="/2019/10/30/我所使用的实用插件/active-power-mode.png" alt></li>
<li>Backgroun Image Plus  </li>
</ol>
<p>可以修改 idea背景，自定义 ide的背景图片 </p>
<ol>
<li>Grep Console </li>
</ol>
<p>自定义日志颜色 ,可以显示克重级别的log,安装完毕在 console 右键打卡<br><img src="/2019/10/30/我所使用的实用插件/grep_console.png" alt></p>
<ol>
<li><p>Free   Mybatis plugin<br>通过mybatis 插件，让 mybatis.xml像 java代码一样编辑</p>
<p>点击绿色箭头直接跳到 xml 文件相应的位置<br><img src="/2019/10/30/我所使用的实用插件/mybatis_plugin.png" alt></p>
<ol>
<li>Mybatis Log Plugin<br>mybatis  现在是java 操作数据库的主流,开发时脚本会直接输出在console中, 但是默认的输出格式不能直接执行<br>而MybatisLogPlugin 可以直接将Mybatis执行的 sql脚本显示出来，可以直接复制执行<br><img src="/2019/10/30/我所使用的实用插件/mybatis_log.png" alt></li>
</ol>
</li>
<li><p>String Manipulation<br> 强大的字符创转换工具<br> alt+ M</p>
<p>切换样式（camelCase, hyphen-lowercase, HYPHEN-UPPERCASE, snake_case, SCREAMING_SNAKE_CASE, dot.case, words lowercase, Words Capitalized, PascalCase）<br>转换为SCREAMING_SNAKE_CASE (或转换为camelCase)<br>转换为 snake_case (或转换为camelCase)<br>转换为dot.case (或转换为camelCase)<br>转换为hyphen-case (或转换为camelCase)<br>转换为hyphen-case (或转换为snake_case)<br>转换为camelCase (或转换为Words)<br>转换为camelCase (或转换为lowercase words)<br>转换为PascalCase (或转换为camelCase)</p>
</li>
</ol>
<p>7.Alibaba java  coding  Guidelines<br>不多说， 规约插件<br><img src="/2019/10/30/我所使用的实用插件/alibaba_guideline.png" alt><br>8.Lombook<br>省略 写一大堆的 set()  get()方法<br>但是不要忘记 添加依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>9.Key  promoter s</p>
<p>Key promoter 是IntelliJ IDEA的快捷键提示插件，会统计你鼠标<br>点击某个功能的次数，提示你应该用什么快捷键，帮助记忆快捷键，等熟悉了之后可以关闭掉这个插件。<br>非常适合刚从 elicpse 转向   IDEA的人士 </p>
<ol>
<li>GsonFormat s<br>可根据json数据快速生成java实体类。<br>自定义个javaBean(无任何内容，就一个空的类)，复制你要解析的Json，<br>然后alt+insert弹出如下界面或者使用快捷键 Alt+S，在里面粘贴刚刚<br>复制的Json，点击OK即可。<br><img src="/2019/10/30/我所使用的实用插件/GsonFormat.png" alt><br>11.Restfulkit </li>
</ol>
<p>Spring MVC网页开发的时候，我们都是通过requestmapping的方式来定义页面的URL地址的，<br>为了找到这个地址我们一般都是cmd+shift+F的方式进行查找，大家都知道，我们URL的命名一个<br>是类requestmapping+方法requestmapping，查找的时候还是有那么一点不方便的，<br>restfultookit就能很方便的帮忙进行查找。</p>
<p>这个restfulkit 还有个使用功能就是 可以自动生成对应请求url的测试数据<br><img src="/2019/10/30/我所使用的实用插件/restfulkit.png" alt></p>
<ol>
<li>JRebel<br>一种热部署生产工具,修改代码后不用重新启动程序, 所有的更改便可以生效 s<br>跳过 重建,重新启动和重新部署周期 </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>hexo博客使用问题</title>
    <url>/2019/10/30/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="hexo-文章如何插入图片"><a href="#hexo-文章如何插入图片" class="headerlink" title="hexo 文章如何插入图片"></a>hexo 文章如何插入图片</h1><p>解决方法</p>
<p>设置站点配置_config.yml:将post_asset_folder: false改为post_asset_folder: true<br>安装插件:npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> — save<br>运行hexo n “XXXXXX”,生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。<br>添加图片:在想添加的位置写入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">![](图片名字.图片格式),例如![](1.png)。</span><br><span class="line"></span><br><span class="line">![](holloween.jpg)</span><br></pre></td></tr></table></figure></p>
<h1 id="不小心上传了-大pdf文件-导致git提交失败"><a href="#不小心上传了-大pdf文件-导致git提交失败" class="headerlink" title="不小心上传了 大pdf文件 ,导致git提交失败"></a>不小心上传了 大pdf文件 ,导致git提交失败</h1><p>git 默认是不能上传超过100M 的文件的，在第一次push失败后再次 push  commit 还是失败 </p>
<p>认为是上次执行失败有缓存的问题<br>在 /my_blog/deploy.git 目录下执行命令:<br>$ git filter-branch -f —prune-empty —index-filter ‘git rm -rf —cached —ignore-unmatch ThinkingInJava/test.data’ —tag-name-filter cat — —all</p>
<p>再次  commit ， 成功</p>
<h1 id="如何在-Hexo-NexT主题内添加pdf插件？"><a href="#如何在-Hexo-NexT主题内添加pdf插件？" class="headerlink" title="如何在 Hexo-NexT主题内添加pdf插件？"></a>如何在 Hexo-NexT主题内添加pdf插件？</h1><p>1.安装插件<br>npm install —save hexo-pdf<br>2.next/_config.yml中修改此处：打开pdf<br>pdf:<br>  enable: true</p>
<h1 id="Default-height"><a href="#Default-height" class="headerlink" title="Default height"></a>Default height</h1><p>  height: 500px<br>  pdfobject:</p>
<pre><code># Use 2.1.1 as default, jsdelivr as default CDN, works everywhere even in China
cdn: //cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js
# CDNJS, provided by cloudflare, maybe the best CDN, but not works in China
#cdn: //cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js
</code></pre><p>3.新建页面<br>hexo new test<br>4.在生成的md文件中添加pdf<br>外部链接：<br><div class="pdf" target="http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf" height></div><br>本地连接：把pdf放置到source文件夹下pdf文件夹下<br><div class="pdf" target="/pdf/文件名.pdf" height></div></p>
<h1 id="hexo-如何设置首页访问量-和-文章详情-访问量"><a href="#hexo-如何设置首页访问量-和-文章详情-访问量" class="headerlink" title="hexo 如何设置首页访问量 和 文章详情 访问量"></a>hexo 如何设置首页访问量 和 文章详情 访问量</h1>]]></content>
  </entry>
  <entry>
    <title>1.8lambda表达式 和 java13新特性</title>
    <url>/2019/10/28/java%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="since-jdk-1-5-关于注解-Annotation"><a href="#since-jdk-1-5-关于注解-Annotation" class="headerlink" title="since  jdk 1.5 关于注解 Annotation"></a>since  jdk 1.5 关于注解 Annotation</h1><p>@Target(ElementType.METHOD)<br>@Retention(RetentionPolicy.SOURCE)<br>public @interface Override {</p>
<p>}<br>这是注解 @Override 的定义，其实它本质上就是 （注解的本质就是一个继承了 Annotation 接口的接口,一种特殊的注释 ）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Override extends Annotation&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射<br>典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，<br>编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。</p>
<h1 id="还有java当中存在的四个元注解"><a href="#还有java当中存在的四个元注解" class="headerlink" title="还有java当中存在的四个元注解"></a>还有java当中存在的四个元注解</h1><p>@Target：注解的作用目标<br>@Retention：注解的生命周期<br>@Documented：注解是否应当被包含在 JavaDoc 文档中<br>@Inherited：是否允许子类继承该注解</p>
<h1 id="四个元注解的-使用"><a href="#四个元注解的-使用" class="headerlink" title="四个元注解的 使用"></a>四个元注解的 使用</h1><p>@Target<br>public  @Interface  Target{<br>    ElementType[]   value ;<br>}<br>当 @Target(value ={ ElementType.Field} )</p>
<p>// @Retention(RetentinoPolicy.)</p>
<h1 id="Class-类中提供了以下一些方法用于反射注解"><a href="#Class-类中提供了以下一些方法用于反射注解" class="headerlink" title="Class 类中提供了以下一些方法用于反射注解"></a>Class 类中提供了以下一些方法用于反射注解</h1><p>getAnnotation：返回指定的注解<br>isAnnotationPresent：判定当前元素是否被指定注解修饰<br>getAnnotations：返回所有的注解<br>getDeclaredAnnotation：返回本元素的指定注解<br>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</p>
<p>————————————-分割线——————————————————————</p>
<h1 id="java中的反射"><a href="#java中的反射" class="headerlink" title="java中的反射"></a>java中的反射</h1><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>通过反射，Java代码可以发现有关已加载类的字段，方法和构造函数的信息，并可以在安全限制内对这些字段，方法和构造函数进行操作。</p>
<h1 id="java-1-8中的-lambda表达式-和-stream-API"><a href="#java-1-8中的-lambda表达式-和-stream-API" class="headerlink" title="java  1.8中的  lambda表达式 和  stream API"></a>java  1.8中的  lambda表达式 和  stream API</h1><p>functional  programing  ，函数可以作为参数进行传递,把行为参数化<br>1.方法体为表达式, 该<br>(parameter)  -&gt;  expresssion<br>(ina ,int b ) -&gt;     return  a + b </p>
<ol>
<li>方法体为代码块, 必须用{}包裹起来,且需要一个 rerurn 返回值<br>(parameter)  -&gt;  expresssion<br>(int a )-&gt; {sout(”a=“+ a )}<br>(int a )-&gt;  {return  a * a }</li>
</ol>
<p>Java13的新特性主要有5的方面：</p>
<p>翻译成中文：<br>350：动态CDS档案<br>351：ZGC：取消提交未使用的内存<br>353：重新实现旧版套接字API<br>354：switch表达式（预览）<br>355：文字块（预览）</p>
<h1 id="新特性-354-switch-表达式增加-yield关键字"><a href="#新特性-354-switch-表达式增加-yield关键字" class="headerlink" title="新特性 354  switch 表达式增加 yield关键字"></a>新特性 354  switch 表达式增加 yield关键字</h1><p>yield 只是结束switch 结构, 原来的 return 直接结束方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test13()&#123;</span><br><span class="line">        int i=10;</span><br><span class="line">        int num = switch (i) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                yield 10;</span><br><span class="line">            case 2:</span><br><span class="line">                yield 20;</span><br><span class="line">            case 10:</span><br><span class="line">                yield 100;</span><br><span class="line">           default:</span><br><span class="line">                yield 0;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="新特性-355-文字块"><a href="#新特性-355-文字块" class="headerlink" title="新特性  355 文字块"></a>新特性  355 文字块</h1><p> 可以把html或者sql , 直接拷贝后嵌入代码中<br> 在Java13中，三个双引号开始，三个双引号结束，如下效果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String html=&quot;&quot;&quot;</span><br><span class="line">   &lt;html&gt;</span><br><span class="line">     &lt;head&gt;</span><br><span class="line">     &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">     &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;p&gt;66666666666666&lt;/p&gt;</span><br><span class="line">    &lt;iframe src=&quot;1.html&quot; width=&quot;600&quot; height=&quot;800&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;                   </span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  System.out.println(html);</span><br></pre></td></tr></table></figure></p>
<p>特别地:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文本块可以表示空串，可要写在两行，如：</span><br><span class="line"></span><br><span class="line">String str=&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;&quot;;</span><br><span class="line"></span><br><span class="line">上述片段等价于，如下：</span><br><span class="line"></span><br><span class="line">String st=&quot;&quot;;</span><br></pre></td></tr></table></figure></p>
<h1 id="新特性-353-重新实现旧版套接字API"><a href="#新特性-353-重新实现旧版套接字API" class="headerlink" title="新特性  353 重新实现旧版套接字API"></a>新特性  353 重新实现旧版套接字API</h1><p>在java.net.Socket和java.net.ServerSocketAPI，以及它们的底层实现，<br>可以追溯到JDK 1.0。该实现是传统Java和C代码的混合，很难维护和调试。该<br>实现使用线程堆栈作为I / O缓冲区，这种方法需要多次增加默认线程堆栈的大小。<br>该实现使用本机数据结构来支持异步关闭，这是多年来的可靠性和移植问题的来源。<br>该实现还存在一些并发问题，需要进行大修才能正确解决。<br>新实现了什么？<br>新的实现NioSocketImpl是的直接替代PlainSocketImpl。它被开发为易于维护<br>和调试。它与新I / O（NIO）实现共享相同的JDK内部基础结构，<br>。它与现有的缓冲区缓存机制集成在一起，因此不需要将线程堆栈用于I / O。它使<br>用java.util.concurrent锁而不是synchronized方法，以便将来可以与光纤<br>配合使用。在JDK 11中，大多数NIO SocketChannel和其他SelectableChan<br>nel实现都是在实现相同目标的情况下重新实现的。</p>
<h1 id="350-动态CDS存档"><a href="#350-动态CDS存档" class="headerlink" title="350   动态CDS存档"></a>350   动态CDS存档</h1><p>目标：<br>提高应用程序类数据共享（AppCDS）的可用性。消除了用户进行试运行以为每个应用程序创建类列表的需求。</p>
<p>该-Xshare:dump选项使用类列表启用的静态归档应继续工作。这包括内置类加载器和用户定义的类加载器的类。    </p>
<h1 id="351-ZGC-取消提交未使用的内存"><a href="#351-ZGC-取消提交未使用的内存" class="headerlink" title="351  ZGC:取消提交未使用的内存"></a>351  ZGC:取消提交未使用的内存</h1><p>ZGC当前不会取消提交并将内存返回给操作系统，即使该内存已经使用了很长时间也是如此。对于所有类型的应用程序和环境，尤其是那些关注内存占用的应用程序和环境，此行为都不是最佳的。例如：</p>
<p>通过使用付费资源的容器环境。</p>
<p>应用程序可能长时间处于空闲状态并与许多其他应用程序共享资源或竞争资源的环境。</p>
<p>应用程序在执行过程中可能会有非常不同的堆空间要求。例如，在启动过程中所需的堆可能会比在稳态执行过程中以后需要的堆大。</p>
<p>HotSpot中的其他垃圾收集器（例如G1和Shenandoah）今天提供了此功能，某些类别的用户发现它非常有用。同一组用户将欢迎将此功能添加到ZGC。</p>
]]></content>
  </entry>
  <entry>
    <title>技术文档翻译</title>
    <url>/2019/10/28/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<h1 id="ssh-com"><a href="#ssh-com" class="headerlink" title="ssh.com"></a>ssh.com</h1><p>PuTTY for Mac is a port of the Windows version of PuTTY. However, there are many options for SSH clients for Mac, and this page discusses several of them.</p>
<p>Contents<br>Using the built-in SSH client in Mac OS X<br>Running SSH from the terminal command line<br>Running SSH with a graphical user interface<br>How to use PuTTY SSH keys with the built-in OpenSSH<br>Ported PuTTY for Mac<br>Installation using HomeBrew<br>Installation using MacPorts<br>Alternatives to PuTTY on the Mac</p>
<p>页面导入pdf 文档 </p>
<div class="pdf" target="./pdf名字.pdf" height></div>
<p>zero-copy<br><img src="/2019/10/28/技术文档翻译/零拷贝.jpg" alt></p>
]]></content>
  </entry>
  <entry>
    <title>报表技术,</title>
    <url>/2019/10/24/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="网页禁止浏览-，跳转app下载？"><a href="#网页禁止浏览-，跳转app下载？" class="headerlink" title="网页禁止浏览  ，跳转app下载？"></a>网页禁止浏览  ，跳转app下载？</h1><h1 id="一、-生成Excel格式报表-根据条件查询导出数据"><a href="#一、-生成Excel格式报表-根据条件查询导出数据" class="headerlink" title="一、 生成Excel格式报表_根据条件查询导出数据"></a>一、 生成Excel格式报表_根据条件查询导出数据</h1><pre><code>   使用POI插件生成报表,从数据库读取数据封装至实体, 写入excel文件,写流
组合的实体类可以前端highchart展示 
*在action中完成数据写到excel文件中，和把文件使用流的形式写到浏览器

逻辑：新建excel文件,新建sheet,新建row,新建cell单元格, 单元格中写数据
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码:</span><br><span class="line">	List&lt;WayBill&gt;  wayBills =  wayBillService.findData(model);</span><br><span class="line">	</span><br><span class="line">	//生成excel文件</span><br><span class="line">	HSSWorkbook  hssWorkbook  = new  HSSWorkBook();</span><br><span class="line">	HSSSheet   sheet   =  hssWorkbook.createSheet(&quot;下单数据&quot;)；</span><br><span class="line">	</span><br><span class="line">	HSSRow headRow  =  sheet.createRow(0);</span><br><span class="line">	headRow.createCell(0).setCellValue(&quot;运单号&quot;);</span><br><span class="line">	headRow.createCell(1).setCellValue(&quot;寄件人&quot;);</span><br><span class="line">	.......</span><br><span class="line">	headRow.createCell(6).setCellValue(&quot;收件人电话&quot;);</span><br><span class="line">	</span><br><span class="line">	//填充表格数据  </span><br><span class="line">	for(WayBill  wayBill   : wayBills )&#123;</span><br><span class="line">		HSSRow  dataRow =  sheet.createRow(sheet.getLastRowNum()+1);</span><br><span class="line">		dataRow.createCell(0).setCellValue(wayBill.getWayBillNum());</span><br><span class="line">		......</span><br><span class="line">		dataRow.crrateCell(6).setCellValue(waybill.getRecAddress());</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	.......</span><br><span class="line">	//下载导出  </span><br><span class="line">  //设置头信息</span><br><span class="line">  ServletApplicationContext.getResponse().setContentType(&quot;application/vnd.ms-excel&quot;);</span><br><span class="line">  String fileName =  &quot;运单数据&quot;；</span><br><span class="line">  String agent =  ServletActionContext.getRequest().getHeader(&quot;user-agent &quot;);</span><br><span class="line">  fileName = FileUtils.encoderDownloaderFileName(fileName ,  agent);</span><br><span class="line">  ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+filemname);</span><br><span class="line">  ServletOutputStream  outputSteam = ServletActionContext.getResponse().getOutputStream();</span><br><span class="line">  //写流 </span><br><span class="line">  hssWorkbook.write(outputStream);</span><br><span class="line">  hssWorkbook.close();</span><br><span class="line">  //视图层不返回</span><br><span class="line">  return  NONE;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>实用技能</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch</title>
    <url>/2019/10/24/elasticsearch/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档进行索引、搜索、排序、过滤。ES比传统关系型数据库，就像如下：</p>
<p>Relation DB  -&gt; DataBase-&gt; Tables-&gt; Rows   -&gt; Colums</p>
<p>ElasticSearch -&gt; Indeces -&gt; Types -&gt; Documents-&gt; Fields</p>
<h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h1><p>Elasticsearch致力于隐藏分布式系统的复杂性。</p>
<p>1）将你的文档分区到不同的容器或者分片(shards)中，它们可以存在于一个或多个节点中。<br>2）将分片均匀的分配到各个节点，对索引和搜索做负载均衡。<br>3）冗余每一个分片，防止硬件故障造成的数据丢失。<br>4）将集群中任意一个节点上的请求路由到相应数据所在的节点。<br>5）无论是增加节点，还是移除节点，分片都可以做到无缝的扩展和迁移</p>
<h1 id="3-ES常见名词解释"><a href="#3-ES常见名词解释" class="headerlink" title="3.ES常见名词解释"></a>3.ES常见名词解释</h1><p>（1）接近实时（NRT）</p>
<p>Elasticsearch是一个接近实时的搜索平台。</p>
<p>（2）集群（cluster）</p>
<p>一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，节点都是通过集群名加入到elasticsearch集群中的。</p>
<p>（3）节点（node）</p>
<p>一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的。</p>
<p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p>
<p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群</p>
<h1 id="（4）索引（index）"><a href="#（4）索引（index）" class="headerlink" title="（4）索引（index）"></a>（4）索引（index）</h1><p>一个索引就是一个拥有几分相似特征的文档的集合。</p>
<h1 id="（5）类型（type）"><a href="#（5）类型（type）" class="headerlink" title="（5）类型（type）"></a>（5）类型（type）</h1><p>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。</p>
<h1 id="（6）文档（document）"><a href="#（6）文档（document）" class="headerlink" title="（6）文档（document）"></a>（6）文档（document）</h1><p>一个文档是一个可被索引的基础信息单元。</p>
<h1 id="（7）分片和复制（shard-amp-replica）"><a href="#（7）分片和复制（shard-amp-replica）" class="headerlink" title="（7）分片和复制（shard &amp; replica）"></a>（7）分片和复制（shard &amp; replica）</h1><p>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：<br>1）允许你水平分割/扩展你的内容容量。<br>2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。</p>
<p>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p>
<p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p>
<p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制（一个索引的完全拷贝）。</p>
]]></content>
  </entry>
  <entry>
    <title>mybatis源码分析</title>
    <url>/2019/10/23/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id><a href="#" class="headerlink" title=" "></a> </h1><p>Note  that  the  parent  and child  were  exeuting with  different registers :<br>chaging   that avariable  in   one   does   not  affect  the  other </p>
<h1 id="mybatis-使用"><a href="#mybatis-使用" class="headerlink" title="mybatis 使用"></a>mybatis 使用</h1><ol>
<li>—#{}是预编译处理，${}是字符串替换， 建议使用#{}    通过使用一个预处理语句你就可以避免重复分析、编译、优化的环节</li>
<li>— mybatis 建议在java代码中 使用通配符<br>String   wildcardname  = “%smi”<br>list<name> names = mapper.selectlike(wildcardname);</name></li>
</ol>
<p><select id="”selectlike”"><br> select * from foo where bar like #{value}
</select><br> //而在sql中拼接 通配符会引起sql注入<br> <select id="”selectlike”"><br>      select * from foo where bar like “%”${value}”%”
 </select></p>
<ol>
<li>如何批量插入<br><insert id="”insertname”"><br> insert into names (name) values (#{value})
</insert><!-- namemapper mapper = sqlsession.getmapper(namemapper.class);
for (string name : names) {
 mapper.insertname(name);
} -->
</li>
</ol>
<p>4.mybatis是否支持延迟加载？如果支持，它的实现原理是什么？<br>———-懒加载其实就是延时加载，即当对象需要用到的时候再去加载  A的内部对象B<br>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。<br>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。<br>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。<br>5.Mapper编写有哪几种方式？# 关于preparedStateemnt<br>    i<br>    ii<br>    iii  使用mapper Scanner</p>
<h1 id="JDBC缺陷总结"><a href="#JDBC缺陷总结" class="headerlink" title="JDBC缺陷总结:"></a>JDBC缺陷总结:</h1><p> 数据库链接创建,释放频繁造成<br> SQL硬编码, 不容易维护<br> 使用prepareStatement向占有符号传参数存在硬编码, 因为where 条件不一定，可能多也可能少<br> 对结果集存在硬编码 ,(查询列名)，将数据库记录封装成pojo比较方便 </p>
<pre><code>两次相同的查询从  sqlSession中取数据 
</code></pre><p>2、怎么判断某两次查询是完全相同的查询？</p>
<p>　　mybatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。</p>
<p>　　2.1 传入的statementId</p>
<p>　　2.2 查询时要求的结果集中的结果范围</p>
<p>　　2.3. 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）</p>
<p>　　2.4 传递给java.sql.Statement要设置的参数值</p>
<p>​————————————-<br>    二级缓存<br><del>删除线</del></p>
<ul>
<li>二级缓存?<br>+</li>
</ul>
<div class="pdf" target="https://github.com/mathewsHan/-Note/blob/master/鸟哥的Linux私房菜–基础学习篇(第三版)%20.pdf" height></div> 
<hr>
]]></content>
  </entry>
  <entry>
    <title>markdown画图</title>
    <url>/2019/10/22/markdown%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<p>hbuilderX<br>自定义主题 </p>
<p>mermaid是一款支持 maekdown语言的插件<br>mermaid官网：<a href="http://knsv.github.io/mermaid/#demos" target="_blank" rel="noopener">http://knsv.github.io/mermaid/#demos</a></p>
]]></content>
      <tags>
        <tag>文档技能</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/07/13/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>深入理解jvm 第 二三七章<br>HotSpot虚拟机<br>对象在内存中 3块区域: 对象头   实例数据 和对齐填充</p>
]]></content>
  </entry>
</search>
